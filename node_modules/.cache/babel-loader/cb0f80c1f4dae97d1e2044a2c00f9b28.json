{"ast":null,"code":"import { classOf } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS } from \"../constants/constants.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { Inject } from \"./inject.js\";\nimport { Scope } from \"./scope.js\";\n/**\n * Get instance options. This options depending on his invocation context.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @param target\n * @param propertyKey\n * @param index\n * @decorator\n */\nexport function Opts(target, propertyKey, index) {\n  Scope(ProviderScope.INSTANCE)(classOf(target));\n  Inject(DI_PARAM_OPTIONS)(target, propertyKey, index);\n}","map":{"version":3,"sources":["../../../src/decorators/opts.ts"],"names":[],"mappings":"AAAA,SAAQ,OAAO,QAAO,YAAY;AAClC,SAAQ,gBAAgB,QAAO,2BAAyB;AACxD,SAAQ,aAAa,QAAO,4BAA0B;AACtD,SAAQ,MAAM,QAAO,aAAW;AAChC,SAAQ,KAAK,QAAO,YAAU;AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCG;AACH,OAAM,SAAU,IAAI,CAAC,MAAW,EAAE,WAA4B,EAAE,KAAa,EAAA;EAC3E,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;EAC9C,MAAM,CAAC,gBAAgB,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC;AACtD","sourceRoot":"","sourcesContent":["import { classOf } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS } from \"../constants/constants.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { Inject } from \"./inject.js\";\nimport { Scope } from \"./scope.js\";\n/**\n * Get instance options. This options depending on his invocation context.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @param target\n * @param propertyKey\n * @param index\n * @decorator\n */\nexport function Opts(target, propertyKey, index) {\n    Scope(ProviderScope.INSTANCE)(classOf(target));\n    Inject(DI_PARAM_OPTIONS)(target, propertyKey, index);\n}\n//# sourceMappingURL=opts.js.map"]},"metadata":{},"sourceType":"module"}