{"ast":null,"code":"import _defineProperty from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { decoratorTypeOf, DecoratorTypes, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options) {\n  return function (target, propertyKey, index) {\n    var bindingType = decoratorTypeOf([target, propertyKey, index]);\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        Store.from(target).merge(\"\".concat(DI_PARAM_OPTIONS, \":\").concat(index), options);\n        break;\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, _defineProperty({}, propertyKey, {\n          options: options\n        }));\n        break;\n      default:\n        throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/decorators/useOpts.ts"],"names":[],"mappings":";AAAA,SAAQ,eAAe,EAAE,cAAc,EAAE,KAAK,EAAE,wBAAwB,QAAO,YAAY;AAC3F,SAAQ,gBAAgB,EAAE,eAAe,QAAO,2BAAyB;AAEzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;AACH,OAAM,SAAU,OAAO,CAAC,OAA6B,EAAA;EACnD,OAAO,UAAC,MAAc,EAAE,WAA4B,EAAE,KAAc,EAAS;IAC3E,IAAM,WAAW,GAAG,eAAe,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;IAEjE,QAAQ,WAAW;MACjB,KAAK,cAAc,CAAC,UAAU;QAC5B,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,IAAA,MAAA,CAAI,gBAAgB,OAAA,MAAA,CAAI,KAAK,GAAI,OAAO,CAAC;QACjE;MAEF,KAAK,cAAc,CAAC,IAAI;QACtB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,eAAe,EAAA,eAAA,KACrC,WAAqB,EAAG;UACvB,OAAO,EAAP;SACD,EACD;QACF;MAEF;QACE,MAAM,IAAI,wBAAwB,CAAC,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;IAAC;EAEhF,CAAC;AACH","sourceRoot":"","sourcesContent":["import { decoratorTypeOf, DecoratorTypes, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options) {\n    return (target, propertyKey, index) => {\n        const bindingType = decoratorTypeOf([target, propertyKey, index]);\n        switch (bindingType) {\n            case DecoratorTypes.PARAM_CTOR:\n                Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);\n                break;\n            case DecoratorTypes.PROP:\n                Store.from(target).merge(INJECTABLE_PROP, {\n                    [propertyKey]: {\n                        options\n                    }\n                });\n                break;\n            default:\n                throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n        }\n    };\n}\n//# sourceMappingURL=useOpts.js.map"]},"metadata":{},"sourceType":"module"}