{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isArray, isClass } from \"@tsed/core\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\nvar lookupProperties = [\"mount\", \"imports\"];\nexport function getTokens(config) {\n  if (!config) {\n    return [];\n  }\n  if (isArray(config)) {\n    return config.filter(isClass).map(function (value) {\n      return {\n        token: value\n      };\n    });\n  }\n  return Object.keys(config).reduce(function (list, route) {\n    return [].concat(_toConsumableArray(list), _toConsumableArray([].concat(config[route]).filter(isClass).map(function (token) {\n      return {\n        route: route,\n        token: token\n      };\n    })));\n  }, []);\n}\nfunction resolveRecursively(providers) {\n  return providers.map(function (_ref) {\n    var token = _ref.token;\n    return GlobalProviders.get(token);\n  }).filter(function (provider) {\n    return (provider === null || provider === void 0 ? void 0 : provider.type) === ProviderType.MODULE && provider.configuration;\n  }).flatMap(function (provider) {\n    return resolveControllers(provider.configuration);\n  });\n}\n/**\n * Return controllers and is base route according to his configuration in module configuration.\n *\n * @param settings\n */\nexport function resolveControllers(settings) {\n  var providers = lookupProperties.flatMap(function (property) {\n    return getTokens(settings[property]);\n  });\n  return [].concat(_toConsumableArray(resolveRecursively(providers)), _toConsumableArray(providers)).filter(function (provider) {\n    return !!provider.route;\n  });\n}","map":{"version":3,"sources":["../../../src/utils/resolveControllers.ts"],"names":[],"mappings":";AAAA,SAAQ,OAAO,EAAE,OAAO,QAAO,YAAY;AAE3C,SAAQ,eAAe,QAAO,kCAAgC;AAC9D,SAAQ,YAAY,QAAO,2BAAyB;AAIpD,IAAM,gBAAgB,GAAG,CAAC,OAAO,EAAE,SAAS,CAAC;AAE7C,OAAM,SAAU,SAAS,CAAC,MAAW,EAAA;EACnC,IAAI,CAAC,MAAM,EAAE;IACX,OAAO,EAAE;EACV;EAED,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE;IACnB,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,UAAC,KAAU,EAAI;MAC/C,OAAO;QAAC,KAAK,EAAE;MAAK,CAAC;IACvB,CAAC,CAAC;EACH;EAED,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,IAAW,EAAE,KAAa,EAAI;IAC/D,UAAA,MAAA,CAAA,kBAAA,CACK,IAAI,GAAA,kBAAA,CACJ,EAAE,CACF,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CACrB,MAAM,CAAC,OAAO,CAAC,CACf,GAAG,CAAC,UAAC,KAAK;MAAA,OAAM;QACf,KAAK,EAAL,KAAK;QACL,KAAK,EAAL;OACD;IAAA,CAAC,CAAC;EAET,CAAC,EAAE,EAAE,CAAC;AACR;AAEA,SAAS,kBAAkB,CAAC,SAAmD,EAAA;EAC7E,OAAO,SAAS,CACb,GAAG,CAAC,UAAA,IAAA;IAAA,IAAE,KAAK,GAAA,IAAA,CAAL,KAAK;IAAA,OAAM,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC;EAAA,EAAC,CAC5C,MAAM,CAAC,UAAC,QAAQ;IAAA,OAAK,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,IAAI,MAAK,YAAY,CAAC,MAAM,IAAI,QAAQ,CAAC,aAAa;EAAA,EAAC,CACtF,OAAO,CAAC,UAAC,QAAkB;IAAA,OAAK,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC;EAAA,EAAC;AAChF;AAEA;;;;AAIG;AACH,OAAM,SAAU,kBAAkB,CAAC,QAAqC,EAAA;EACtE,IAAM,SAAS,GAAG,gBAAgB,CAAC,OAAO,CAAC,UAAC,QAAQ;IAAA,OAAK,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;EAAA,EAAC;EAEvF,OAAO,GAAA,MAAA,CAAA,kBAAA,CAAI,kBAAkB,CAAC,SAAS,CAAC,GAAA,kBAAA,CAAK,SAAS,GAAE,MAAM,CAAC,UAAC,QAAQ;IAAA,OAAK,CAAC,CAAC,QAAQ,CAAC,KAAK;EAAA,EAAU;AACzG","sourceRoot":"","sourcesContent":["import { isArray, isClass } from \"@tsed/core\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\nconst lookupProperties = [\"mount\", \"imports\"];\nexport function getTokens(config) {\n    if (!config) {\n        return [];\n    }\n    if (isArray(config)) {\n        return config.filter(isClass).map((value) => {\n            return { token: value };\n        });\n    }\n    return Object.keys(config).reduce((list, route) => {\n        return [\n            ...list,\n            ...[]\n                .concat(config[route])\n                .filter(isClass)\n                .map((token) => ({\n                route,\n                token\n            }))\n        ];\n    }, []);\n}\nfunction resolveRecursively(providers) {\n    return providers\n        .map(({ token }) => GlobalProviders.get(token))\n        .filter((provider) => provider?.type === ProviderType.MODULE && provider.configuration)\n        .flatMap((provider) => resolveControllers(provider.configuration));\n}\n/**\n * Return controllers and is base route according to his configuration in module configuration.\n *\n * @param settings\n */\nexport function resolveControllers(settings) {\n    const providers = lookupProperties.flatMap((property) => getTokens(settings[property]));\n    return [...resolveRecursively(providers), ...providers].filter((provider) => !!provider.route);\n}\n//# sourceMappingURL=resolveControllers.js.map"]},"metadata":{},"sourceType":"module"}