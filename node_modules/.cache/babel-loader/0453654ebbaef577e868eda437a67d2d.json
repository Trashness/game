{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { importPackage } from \"@tsed/core\";\nimport { injectProperty } from \"./inject.js\";\n/**\n * Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @LazyInject(\"PlatformException\", () => import(\"@tsed/platform-exceptions\"))\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param packageName\n * @param resolver\n * @param optional\n * @returns {Function}\n * @decorator\n */\nexport function LazyInject(key, _resolver) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$optional = _ref.optional,\n    optional = _ref$optional === void 0 ? false : _ref$optional,\n    _ref$packageName = _ref.packageName,\n    packageName = _ref$packageName === void 0 ? _resolver.toString() : _ref$packageName;\n  return function (target, propertyKey) {\n    var bean, token;\n    injectProperty(target, propertyKey, {\n      resolver: function resolver(injector) {\n        return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var exports;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                if (token) {\n                  _context.next = 16;\n                  break;\n                }\n                _context.next = 3;\n                return importPackage(packageName, _resolver, optional);\n              case 3:\n                exports = _context.sent;\n                token = exports[key];\n                if (token) {\n                  _context.next = 8;\n                  break;\n                }\n                if (optional) {\n                  _context.next = 8;\n                  break;\n                }\n                throw new Error(\"Unable to lazy load the \\\"\".concat(key, \"\\\". The token isn't a valid token provider.\"));\n              case 8:\n                if (!token) {\n                  _context.next = 14;\n                  break;\n                }\n                _context.next = 11;\n                return injector.lazyInvoke(token);\n              case 11:\n                _context.t0 = _context.sent;\n                _context.next = 15;\n                break;\n              case 14:\n                _context.t0 = {};\n              case 15:\n                bean = _context.t0;\n              case 16:\n                return _context.abrupt(\"return\", bean);\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n      }\n    });\n  };\n}\n/**\n * Optionally Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @OptionalLazyInject(\"@tsed/platform-exceptions\")\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param resolver\n * @returns {Function}\n * @decorator\n */\nexport function OptionalLazyInject(key, resolver) {\n  return LazyInject(key, resolver, {\n    optional: true\n  });\n}","map":{"version":3,"sources":["../../../src/decorators/lazyInject.ts"],"names":[],"mappings":";;AAAA,SAAQ,aAAa,QAAO,YAAY;AACxC,SAAQ,cAAc,QAAO,aAAW;AAExC;;;;;;;;;;;;;;;;;;;AAmBG;AACH,OAAM,SAAU,UAAU,CACxB,GAAW,EACX,SAAmB,EACmF;EAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAF,CAAA,CAAE;IAAA,aAAA,GAAA,IAAA,CAArG,QAAQ;IAAR,QAAQ,GAAA,aAAA,cAAG,KAAK,GAAA,aAAA;IAAA,gBAAA,GAAA,IAAA,CAAE,WAAW;IAAX,WAAW,GAAA,gBAAA,cAAG,SAAQ,CAAC,QAAQ,EAAE,GAAA,gBAAA;EAEpD,OAAO,UAAC,MAAW,EAAE,WAAmB,EAAgB;IACtD,IAAI,IAAS,EAAE,KAAU;IACzB,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE;MAClC,QAAQ,WAAA,SAAC,QAAQ,EAAA;QACf,oBAAA,iBAAA,eAAA,mBAAA,GAAA,IAAA,CAAO,SAAA,QAAA;UAAA,IAAA,OAAA;UAAA,OAAA,mBAAA,GAAA,IAAA,UAAA,SAAA,QAAA;YAAA,kBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;cAAA;gBAAA,IACA,KAAK;kBAAA,QAAA,CAAA,IAAA;kBAAA;gBAAA;gBAAA,QAAA,CAAA,IAAA;gBAAA,OACc,aAAa,CAAC,WAAW,EAAE,SAAQ,EAAE,QAAQ,CAAC;cAAA;gBAA9D,OAAO,GAAA,QAAA,CAAA,IAAA;gBACb,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;gBAAC,IAEhB,KAAK;kBAAA,QAAA,CAAA,IAAA;kBAAA;gBAAA;gBAAA,IACH,QAAQ;kBAAA,QAAA,CAAA,IAAA;kBAAA;gBAAA;gBAAA,MACL,IAAI,KAAK,8BAAA,MAAA,CAA6B,GAAG,iDAA8C;cAAA;gBAAA,KAI1F,KAAK;kBAAA,QAAA,CAAA,IAAA;kBAAA;gBAAA;gBAAA,QAAA,CAAA,IAAA;gBAAA,OAAS,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC;cAAA;gBAAA,QAAA,CAAA,EAAA,GAAA,QAAA,CAAA,IAAA;gBAAA,QAAA,CAAA,IAAA;gBAAA;cAAA;gBAAA,QAAA,CAAA,EAAA,GAAG,CAAA,CAAE;cAAA;gBAApD,IAAI,GAAA,QAAA,CAAA,EAAA;cAAA;gBAAA,OAAA,QAAA,CAAA,MAAA,WAGC,IAAI;cAAA;cAAA;gBAAA,OAAA,QAAA,CAAA,IAAA;YAAA;UAAA,GAAA,OAAA;QAAA,CACZ;MACH;KACD,CAAC;EACJ,CAAC;AACH;AAEA;;;;;;;;;;;;;;;;;AAiBG;AACH,OAAM,SAAU,kBAAkB,CAAC,GAAW,EAAE,QAAmB,EAAA;EACjE,OAAQ,UAAkB,CAAC,GAAG,EAAE,QAAQ,EAAE;IAAC,QAAQ,EAAE;EAAI,CAAC,CAAC;AAC7D","sourceRoot":"","sourcesContent":["import { importPackage } from \"@tsed/core\";\nimport { injectProperty } from \"./inject.js\";\n/**\n * Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @LazyInject(\"PlatformException\", () => import(\"@tsed/platform-exceptions\"))\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param packageName\n * @param resolver\n * @param optional\n * @returns {Function}\n * @decorator\n */\nexport function LazyInject(key, resolver, { optional = false, packageName = resolver.toString() } = {}) {\n    return (target, propertyKey) => {\n        let bean, token;\n        injectProperty(target, propertyKey, {\n            resolver(injector) {\n                return async () => {\n                    if (!token) {\n                        const exports = await importPackage(packageName, resolver, optional);\n                        token = exports[key];\n                        if (!token) {\n                            if (!optional) {\n                                throw new Error(`Unable to lazy load the \"${key}\". The token isn\\'t a valid token provider.`);\n                            }\n                        }\n                        bean = token ? await injector.lazyInvoke(token) : {};\n                    }\n                    return bean;\n                };\n            }\n        });\n    };\n}\n/**\n * Optionally Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @OptionalLazyInject(\"@tsed/platform-exceptions\")\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param resolver\n * @returns {Function}\n * @decorator\n */\nexport function OptionalLazyInject(key, resolver) {\n    return LazyInject(key, resolver, { optional: true });\n}\n//# sourceMappingURL=lazyInject.js.map"]},"metadata":{},"sourceType":"module"}