{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT } from \"./utils\";\nexport function generateKeyPair() {\n  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randomBytes(KEY_PAIR_SEED_LENGTH);\n  return ed25519.generateKeyPairFromSeed(seed);\n}\nexport function signJWT(_x, _x2, _x3, _x4) {\n  return _signJWT.apply(this, arguments);\n}\nfunction _signJWT() {\n  _signJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sub, aud, ttl, keyPair) {\n    var iat,\n      header,\n      iss,\n      exp,\n      payload,\n      data,\n      signature,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          iat = _args.length > 4 && _args[4] !== undefined ? _args[4] : fromMiliseconds(Date.now());\n          header = {\n            alg: JWT_IRIDIUM_ALG,\n            typ: JWT_IRIDIUM_TYP\n          };\n          iss = encodeIss(keyPair.publicKey);\n          exp = iat + ttl;\n          payload = {\n            iss: iss,\n            sub: sub,\n            aud: aud,\n            iat: iat,\n            exp: exp\n          };\n          data = encodeData({\n            header: header,\n            payload: payload\n          });\n          signature = ed25519.sign(keyPair.secretKey, data);\n          return _context.abrupt(\"return\", encodeJWT({\n            header: header,\n            payload: payload,\n            signature: signature\n          }));\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _signJWT.apply(this, arguments);\n}\nexport function verifyJWT(_x5) {\n  return _verifyJWT.apply(this, arguments);\n}\nfunction _verifyJWT() {\n  _verifyJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jwt) {\n    var _decodeJWT, header, payload, data, signature, publicKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _decodeJWT = decodeJWT(jwt), header = _decodeJWT.header, payload = _decodeJWT.payload, data = _decodeJWT.data, signature = _decodeJWT.signature;\n          if (!(header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP)) {\n            _context2.next = 3;\n            break;\n          }\n          throw new Error(\"JWT must use EdDSA algorithm\");\n        case 3:\n          publicKey = decodeIss(payload.iss);\n          return _context2.abrupt(\"return\", ed25519.verify(publicKey, data, signature));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _verifyJWT.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/api.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH, } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT, } from \"./utils\";\nexport function generateKeyPair(seed = randomBytes(KEY_PAIR_SEED_LENGTH)) {\n    return ed25519.generateKeyPairFromSeed(seed);\n}\nexport async function signJWT(sub, aud, ttl, keyPair, iat = fromMiliseconds(Date.now())) {\n    const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };\n    const iss = encodeIss(keyPair.publicKey);\n    const exp = iat + ttl;\n    const payload = { iss, sub, aud, iat, exp };\n    const data = encodeData({ header, payload });\n    const signature = ed25519.sign(keyPair.secretKey, data);\n    return encodeJWT({ header, payload, signature });\n}\nexport async function verifyJWT(jwt) {\n    const { header, payload, data, signature } = decodeJWT(jwt);\n    if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {\n        throw new Error(\"JWT must use EdDSA algorithm\");\n    }\n    const publicKey = decodeIss(payload.iss);\n    return ed25519.verify(publicKey, data, signature);\n}\n//# sourceMappingURL=api.js.map"]},"metadata":{},"sourceType":"module"}