{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"options\"];\nimport { decoratorTypeOf, DecoratorTypes, isPromise, Metadata, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InvalidPropertyTokenError } from \"../errors/InvalidPropertyTokenError.js\";\nimport { getContext } from \"../utils/asyncHookContext.js\";\nexport function injectProperty(target, propertyKey, options) {\n  Store.from(target).merge(INJECTABLE_PROP, _defineProperty({}, propertyKey, _objectSpread({\n    bindingType: DecoratorTypes.PROP,\n    propertyKey: propertyKey\n  }, options)));\n}\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param token A token provider or token provider group\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(token) {\n  var onGet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (bean) {\n    return bean;\n  };\n  return function (target, propertyKey, descriptor) {\n    var bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        if (token) {\n          var paramTypes = Metadata.getParamTypes(target, propertyKey);\n          var type = paramTypes[descriptor];\n          paramTypes[descriptor] = type === Array ? [token] : token;\n          Metadata.setParamTypes(target, propertyKey, paramTypes);\n        }\n        break;\n      case DecoratorTypes.PROP:\n        var useType = token || Metadata.getType(target, propertyKey);\n        var originalType = Metadata.getType(target, propertyKey);\n        if (useType === Object) {\n          throw new InvalidPropertyTokenError(target, propertyKey);\n        }\n        injectProperty(target, propertyKey, {\n          resolver: function resolver(injector, locals, _ref) {\n            var options = _ref.options,\n              invokeOptions = _objectWithoutProperties(_ref, _excluded);\n            var originalType = Metadata.getType(target, propertyKey);\n            locals.set(DI_PARAM_OPTIONS, _objectSpread({}, options));\n            if (originalType === Array) {\n              var _bean;\n              if (!_bean) {\n                _bean = injector.getMany(token, locals, invokeOptions);\n                locals.delete(DI_PARAM_OPTIONS);\n              }\n              _bean.forEach(function (instance, index) {\n                if (isPromise(_bean)) {\n                  instance.then(function (result) {\n                    _bean[index] = result;\n                  });\n                }\n              });\n              return function () {\n                return onGet(_bean);\n              };\n            }\n            var bean;\n            if (!bean) {\n              bean = injector.invoke(useType, locals, invokeOptions);\n              locals.delete(DI_PARAM_OPTIONS);\n            }\n            if (isPromise(bean)) {\n              bean.then(function (result) {\n                bean = result;\n              });\n            }\n            return function () {\n              return onGet(bean);\n            };\n          }\n        });\n        break;\n      default:\n        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n    }\n  };\n}\n/**\n * Inject a context like PlatformContext or any BaseContext.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @InjectContext()\n *   ctx?: Context;\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n */\nexport function InjectContext() {\n  return function (target, propertyKey) {\n    injectProperty(target, propertyKey, {\n      resolver: function resolver() {\n        return function () {\n          return getContext();\n        };\n      }\n    });\n  };\n}","map":{"version":3,"sources":["../../../src/decorators/inject.ts"],"names":[],"mappings":";;;;AAAA,SAAQ,eAAe,EAAE,cAAc,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,wBAAwB,QAAO,YAAY;AAChH,SAAQ,gBAAgB,EAAE,eAAe,QAAO,2BAAyB;AACzE,SAAQ,yBAAyB,QAAO,wCAAsC;AAG9E,SAAQ,UAAU,QAAO,8BAA4B;AAErD,OAAM,SAAU,cAAc,CAAC,MAAW,EAAE,WAAmB,EAAE,OAA2C,EAAA;EAC1G,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,eAAe,EAAA,eAAA,KACrC,WAAW,EAAA,aAAA;IACV,WAAW,EAAE,cAAc,CAAC,IAAI;IAChC,WAAW,EAAX;EAAW,GACR,OAAO,GAEZ;AACJ;AAEA;;;;;;;;;;;;;;;;;AAiBG;AACH,OAAM,SAAU,MAAM,CAAC,KAA6C,EAA6B;EAAA,IAA3B,KAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAQ,UAAC,IAAS;IAAA,OAAK,IAAI;EAAA;EAC/F,OAAO,UAAC,MAAW,EAAE,WAAmB,EAAE,UAAsD,EAAgB;IAC9G,IAAM,WAAW,GAAG,eAAe,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAEtE,QAAQ,WAAW;MACjB,KAAK,cAAc,CAAC,UAAU;QAC5B,IAAI,KAAK,EAAE;UACT,IAAM,UAAU,GAAG,QAAQ,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC;UAC9D,IAAM,IAAI,GAAG,UAAU,CAAC,UAAoB,CAAC;UAE7C,UAAU,CAAC,UAAoB,CAAC,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,CAAC,GAAG,KAAK;UAEnE,QAAQ,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC;QACxD;QACD;MAEF,KAAK,cAAc,CAAC,IAAI;QACtB,IAAM,OAAO,GAAG,KAAK,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC;QAC9D,IAAM,YAAY,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC;QAE1D,IAAI,OAAO,KAAK,MAAM,EAAE;UACtB,MAAM,IAAI,yBAAyB,CAAC,MAAM,EAAE,WAAW,CAAC;QACzD;QAED,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE;UAClC,QAAQ,WAAA,SAAC,QAAQ,EAAE,MAAM,EAAA,IAAA,EAA6B;YAAA,IAA1B,OAAO,GAAA,IAAA,CAAP,OAAO;cAAK,aAAa,GAAA,wBAAA,CAAA,IAAA,EAAA,SAAA;YACnD,IAAM,YAAY,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC;YAC1D,MAAM,CAAC,GAAG,CAAC,gBAAgB,EAAA,aAAA,KAAM,OAAO,EAAE;YAE1C,IAAI,YAAY,KAAK,KAAK,EAAE;cAC1B,IAAI,KAAuB;cAE3B,IAAI,CAAC,KAAI,EAAE;gBACT,KAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,EAAE,aAAa,CAAC;gBACrD,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;cAChC;cAED,KAAI,CAAC,OAAO,CAAC,UAAC,QAAa,EAAE,KAAK,EAAI;gBACpC,IAAI,SAAS,CAAC,KAAI,CAAC,EAAE;kBACnB,QAAQ,CAAC,IAAI,CAAC,UAAC,MAAW,EAAI;oBAC5B,KAAK,CAAC,KAAK,CAAC,GAAG,MAAM;kBACvB,CAAC,CAAC;gBACH;cACH,CAAC,CAAC;cAEF,OAAO;gBAAA,OAAM,KAAK,CAAC,KAAI,CAAC;cAAA;YACzB;YAED,IAAI,IAAS;YAEb,IAAI,CAAC,IAAI,EAAE;cACT,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,EAAE,aAAa,CAAC;cACtD,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;YAChC;YAED,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;cACnB,IAAI,CAAC,IAAI,CAAC,UAAC,MAAW,EAAI;gBACxB,IAAI,GAAG,MAAM;cACf,CAAC,CAAC;YACH;YAED,OAAO;cAAA,OAAM,KAAK,CAAC,IAAI,CAAC;YAAA;UAC1B;SACD,CAAC;QACF;MAEF;QACE,MAAM,IAAI,wBAAwB,CAAC,MAAM,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAAC;EAEpF,CAAC;AACH;AAEA;;;;;;;;;;;;;AAaG;AACH,OAAM,SAAU,aAAa,CAAA,EAAA;EAC3B,OAAO,UAAC,MAAW,EAAE,WAAmB,EAAgB;IACtD,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE;MAClC,QAAQ,WAAA,SAAA,EAAA;QACN,OAAO;UAAA,OAAM,UAAU,EAAE;QAAA;MAC3B;KACD,CAAC;EACJ,CAAC;AACH","sourceRoot":"","sourcesContent":["import { decoratorTypeOf, DecoratorTypes, isPromise, Metadata, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InvalidPropertyTokenError } from \"../errors/InvalidPropertyTokenError.js\";\nimport { getContext } from \"../utils/asyncHookContext.js\";\nexport function injectProperty(target, propertyKey, options) {\n    Store.from(target).merge(INJECTABLE_PROP, {\n        [propertyKey]: {\n            bindingType: DecoratorTypes.PROP,\n            propertyKey,\n            ...options\n        }\n    });\n}\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param token A token provider or token provider group\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(token, onGet = (bean) => bean) {\n    return (target, propertyKey, descriptor) => {\n        const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n        switch (bindingType) {\n            case DecoratorTypes.PARAM_CTOR:\n                if (token) {\n                    const paramTypes = Metadata.getParamTypes(target, propertyKey);\n                    const type = paramTypes[descriptor];\n                    paramTypes[descriptor] = type === Array ? [token] : token;\n                    Metadata.setParamTypes(target, propertyKey, paramTypes);\n                }\n                break;\n            case DecoratorTypes.PROP:\n                const useType = token || Metadata.getType(target, propertyKey);\n                const originalType = Metadata.getType(target, propertyKey);\n                if (useType === Object) {\n                    throw new InvalidPropertyTokenError(target, propertyKey);\n                }\n                injectProperty(target, propertyKey, {\n                    resolver(injector, locals, { options, ...invokeOptions }) {\n                        const originalType = Metadata.getType(target, propertyKey);\n                        locals.set(DI_PARAM_OPTIONS, { ...options });\n                        if (originalType === Array) {\n                            let bean;\n                            if (!bean) {\n                                bean = injector.getMany(token, locals, invokeOptions);\n                                locals.delete(DI_PARAM_OPTIONS);\n                            }\n                            bean.forEach((instance, index) => {\n                                if (isPromise(bean)) {\n                                    instance.then((result) => {\n                                        bean[index] = result;\n                                    });\n                                }\n                            });\n                            return () => onGet(bean);\n                        }\n                        let bean;\n                        if (!bean) {\n                            bean = injector.invoke(useType, locals, invokeOptions);\n                            locals.delete(DI_PARAM_OPTIONS);\n                        }\n                        if (isPromise(bean)) {\n                            bean.then((result) => {\n                                bean = result;\n                            });\n                        }\n                        return () => onGet(bean);\n                    }\n                });\n                break;\n            default:\n                throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n        }\n    };\n}\n/**\n * Inject a context like PlatformContext or any BaseContext.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @InjectContext()\n *   ctx?: Context;\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n */\nexport function InjectContext() {\n    return (target, propertyKey) => {\n        injectProperty(target, propertyKey, {\n            resolver() {\n                return () => getContext();\n            }\n        });\n    };\n}\n//# sourceMappingURL=inject.js.map"]},"metadata":{},"sourceType":"module"}