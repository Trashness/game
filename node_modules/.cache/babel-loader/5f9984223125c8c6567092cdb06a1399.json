{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\nimport { useConfig } from './useConfig';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var _useConfig = useConfig(),\n    refresh = _useConfig.refresh;\n  var potentialRawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      var _a;\n      return chainId !== undefined ? encodeCallData(call, chainId, Object.assign(Object.assign({}, queryParams), {\n        refresh: (_a = queryParams.refresh) !== null && _a !== void 0 ? _a : refresh\n      })) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    return call && {\n      address: call.contract.address.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var rawCalls = useMemo(function () {\n    return potentialRawCalls.map(function (potentialCall) {\n      return potentialCall instanceof Error ? undefined : potentialCall;\n    });\n  }, [potentialRawCalls]);\n  var results = useRawCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      if (potentialRawCalls[idx] instanceof Error) {\n        return {\n          value: undefined,\n          error: potentialRawCalls[idx]\n        };\n      }\n      return decodeCallResult(calls[idx], result);\n    });\n  }, [results]);\n}","map":{"version":3,"sources":["../../../../src/hooks/useCall.ts"],"names":[],"mappings":"AAAA,SAAS,OAAO,QAAQ,OAAO;AAG/B,SAAS,WAAW,QAAQ,eAAe;AAC3C,SAAqB,gBAAgB,EAAE,cAAc,QAAQ,YAAY;AAEzE,SAAS,UAAU,QAAQ,cAAc;AACzC,SAAS,SAAS,QAAQ,aAAa;AAoCvC;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BG;AACH,OAAM,SAAU,OAAO,CACrB,IAAyB,EACI;EAAA,IAA7B,WAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAA2B,CAAA,CAAE;EAE7B,OAAO,QAAQ,CAAC,CAAC,IAAI,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;AACzC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAwBG;AACH,OAAM,SAAU,QAAQ,CAAC,KAAuB,EAA+B;EAAA,IAA7B,WAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAA2B,CAAA,CAAE;EAC7E,IAAM,OAAO,GAAG,UAAU,CAAC;IAAE,WAAW,EAAX;EAAW,CAAE,CAAC;EAC3C,IAAA,UAAA,GAAoB,SAAS,EAAE;IAAvB,OAAO,GAAA,UAAA,CAAP,OAAO;EAEf,IAAM,iBAAiB,GAAG,OAAO,CAC/B;IAAA,OACE,KAAK,CAAC,GAAG,CAAC,UAAC,IAAI,EAAI;;MACjB,OAAA,OAAO,KAAK,SAAS,GACjB,cAAc,CAAC,IAAI,EAAE,OAAO,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,WAAW,CAAA,EAAA;QAAE,OAAO,EAAE,CAAA,EAAA,GAAA,WAAW,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI;MAAO,CAAA,CAAA,CAAG,GAC1F,SAAS;KAAA,CACd;EAAA,GACH,CACE,IAAI,CAAC,SAAS,CACZ,KAAK,CAAC,GAAG,CACP,UAAC,IAAI;IAAA,OAAK,IAAI,IAAI;MAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE;MAAE,MAAM,EAAE,IAAI,CAAC,MAAM;MAAE,IAAI,EAAE,IAAI,CAAC;IAAI,CAAE;EAAA,EACzG,CACF,EACD,OAAO,CACR,CACF;EAED,IAAM,QAAQ,GAAG,OAAO,CACtB;IAAA,OAAM,iBAAiB,CAAC,GAAG,CAAC,UAAC,aAAa;MAAA,OAAM,aAAa,YAAY,KAAK,GAAG,SAAS,GAAG,aAAa;IAAA,CAAC,CAAC;EAAA,GAC5G,CAAC,iBAAiB,CAAC,CACpB;EAED,IAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC;EACrC,OAAO,OAAO,CACZ;IAAA,OACE,OAAO,CAAC,GAAG,CAAC,UAAC,MAAM,EAAE,GAAG,EAAI;MAC1B,IAAI,iBAAiB,CAAC,GAAG,CAAC,YAAY,KAAK,EAAE;QAC3C,OAAO;UAAE,KAAK,EAAE,SAAS;UAAE,KAAK,EAAE,iBAAiB,CAAC,GAAG;QAAU,CAAE;MACpE;MACD,OAAO,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC;IAC7C,CAAC,CAAC;EAAA,GACJ,CAAC,OAAO,CAAC,CACV;AACH","sourceRoot":"","sourcesContent":["import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\nimport { useConfig } from './useConfig';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall(call, queryParams = {}) {\n    return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls, queryParams = {}) {\n    const chainId = useChainId({ queryParams });\n    const { refresh } = useConfig();\n    const potentialRawCalls = useMemo(() => calls.map((call) => {\n        var _a;\n        return chainId !== undefined\n            ? encodeCallData(call, chainId, Object.assign(Object.assign({}, queryParams), { refresh: (_a = queryParams.refresh) !== null && _a !== void 0 ? _a : refresh }))\n            : undefined;\n    }), [\n        JSON.stringify(calls.map((call) => call && { address: call.contract.address.toLowerCase(), method: call.method, args: call.args })),\n        chainId,\n    ]);\n    const rawCalls = useMemo(() => potentialRawCalls.map((potentialCall) => (potentialCall instanceof Error ? undefined : potentialCall)), [potentialRawCalls]);\n    const results = useRawCalls(rawCalls);\n    return useMemo(() => results.map((result, idx) => {\n        if (potentialRawCalls[idx] instanceof Error) {\n            return { value: undefined, error: potentialRawCalls[idx] };\n        }\n        return decodeCallResult(calls[idx], result);\n    }), [results]);\n}\n//# sourceMappingURL=useCall.js.map"]},"metadata":{},"sourceType":"module"}