{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nvar selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n  var res = start;\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  var dynamicOffset = calls.length * 0x20;\n  // number of items in the array\n  res += encodeUint(calls.length);\n  var _iterator = _createForOfIteratorHelper(calls),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var call = _step.value;\n      // offset of the current call\n      res += encodeUint(dynamicOffset);\n      // offset for the next call - current offset\n      // + length of the current call\n      // + space taken by the current offset\n      // + the first item in the next tuple - address for the next call\n      // + space taken by the offset for the next call data\n      dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(calls),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _call = _step2.value;\n      // address + calldata offset\n      dynamicOffset = 0x40;\n      res += '000000000000000000000000' + _call[0].slice(2).toLowerCase();\n      res += encodeUint(dynamicOffset);\n      // call data length\n      res += buffLength(_call[1]).toString(16).padStart(64, '0');\n      // calldata\n      res += _call[1].slice(2).padEnd(bufPaddedLength(_call[1]) * 2, '0');\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return res;\n}\nexport function encodeTryAggregate(b, calls) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  var res = selector;\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  var dynamicOffset = 0x40;\n  res += b ? trueEncoded : falseEncoded;\n  res += encodeUint(dynamicOffset);\n  // encode dynamic array of calls\n  return encodeCalls(res, calls);\n}","map":{"version":3,"sources":["../../../../../src/abi/multicall2/encoder.ts"],"names":[],"mappings":";AAAA,SAAS,UAAU,EAAE,eAAe,EAAE,UAAU,QAAQ,WAAW;AACnE,SAAS,SAAS,EAAE,YAAY,EAAE,WAAW,QAAQ,aAAa;AAElE,IAAM,QAAQ,GAAG,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC;AAErD,OAAM,SAAU,WAAW,CAAC,KAAa,EAAE,KAAyB,EAAA;EAClE,IAAI,GAAG,GAAG,KAAK;EACf;EACA;EACA,IAAI,aAAa,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI;EACvC;EACA,GAAG,IAAI,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;EAAA,IAAA,SAAA,GAAA,0BAAA,CACZ,KAAK;IAAA,KAAA;EAAA;IAAxB,KAAA,SAAA,CAAA,CAAA,MAAA,KAAA,GAAA,SAAA,CAAA,CAAA,IAAA,IAAA,GAA0B;MAAA,IAAf,IAAI,GAAA,KAAA,CAAA,KAAA;MACb;MACA,GAAG,IAAI,UAAU,CAAC,aAAa,CAAC;MAChC;MACA;MACA;MACA;MACA;MACA,aAAa,IAAI,CAAC,GAAG,IAAI,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;EACrD,SAAA,GAAA;IAAA,SAAA,CAAA,CAAA,CAAA,GAAA;EAAA;IAAA,SAAA,CAAA,CAAA;EAAA;EAAA,IAAA,UAAA,GAAA,0BAAA,CAEkB,KAAK;IAAA,MAAA;EAAA;IAAxB,KAAA,UAAA,CAAA,CAAA,MAAA,MAAA,GAAA,UAAA,CAAA,CAAA,IAAA,IAAA,GAA0B;MAAA,IAAf,KAAI,GAAA,MAAA,CAAA,KAAA;MACb;MACA,aAAa,GAAG,IAAI;MACpB,GAAG,IAAI,0BAA0B,GAAG,KAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE;MAClE,GAAG,IAAI,UAAU,CAAC,aAAa,CAAC;MAEhC;MACA,GAAG,IAAI,UAAU,CAAC,KAAI,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;MACzD;MACA,GAAG,IAAI,KAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,KAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC;;EAClE,SAAA,GAAA;IAAA,UAAA,CAAA,CAAA,CAAA,GAAA;EAAA;IAAA,UAAA,CAAA,CAAA;EAAA;EAED,OAAO,GAAG;AACZ;AAEA,OAAM,SAAU,kBAAkB,CAAC,CAAU,EAAE,KAAyB,EAAA;EACtE;EACA,IAAI,GAAG,GAAG,QAAQ;EAElB;EACA;EACA,IAAM,aAAa,GAAG,IAAI;EAC1B,GAAG,IAAI,CAAC,GAAG,WAAW,GAAG,YAAY;EACrC,GAAG,IAAI,UAAU,CAAC,aAAa,CAAC;EAEhC;EACA,OAAO,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC;AAChC","sourceRoot":"","sourcesContent":["import { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nconst selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n    let res = start;\n    // the first offset is calls.length * 0x20 because the first\n    // item of a dynamic array starts after all offsets\n    let dynamicOffset = calls.length * 0x20;\n    // number of items in the array\n    res += encodeUint(calls.length);\n    for (const call of calls) {\n        // offset of the current call\n        res += encodeUint(dynamicOffset);\n        // offset for the next call - current offset\n        // + length of the current call\n        // + space taken by the current offset\n        // + the first item in the next tuple - address for the next call\n        // + space taken by the offset for the next call data\n        dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n    }\n    for (const call of calls) {\n        // address + calldata offset\n        dynamicOffset = 0x40;\n        res += '000000000000000000000000' + call[0].slice(2).toLowerCase();\n        res += encodeUint(dynamicOffset);\n        // call data length\n        res += buffLength(call[1]).toString(16).padStart(64, '0');\n        // calldata\n        res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0');\n    }\n    return res;\n}\nexport function encodeTryAggregate(b, calls) {\n    // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n    let res = selector;\n    // offset of the array is 0x40 because we need to\n    // encode requireSuccess flag and the offset itself\n    const dynamicOffset = 0x40;\n    res += b ? trueEncoded : falseEncoded;\n    res += encodeUint(dynamicOffset);\n    // encode dynamic array of calls\n    return encodeCalls(res, calls);\n}\n//# sourceMappingURL=encoder.js.map"]},"metadata":{},"sourceType":"module"}