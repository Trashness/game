{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore.esm.js';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.esm.js';\nimport { useQueryClient } from './QueryClientProvider.esm.js';\nimport { useIsRestoring } from './isRestoring.esm.js';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.esm.js';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense.esm.js';\nfunction useBaseQuery(options, Observer) {\n  var queryClient = useQueryClient({\n    context: options.context\n  });\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  var _React$useState = React.useState(function () {\n      return new Observer(queryClient, defaultedOptions);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    observer = _React$useState2[0];\n  var result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return undefined;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  } // Handle error boundary\n\n  if (getHasError({\n    result: result,\n    errorResetBoundary: errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport { useBaseQuery };","map":{"version":3,"sources":["../../src/useBaseQuery.ts"],"names":["ensurePreventErrorBoundaryRetry","useSyncExternalStore","observer","listeners"],"mappings":";;;;;;;;;;;AAiBO,SAAA,YAAA,CAAA,OAAA,EAAA,QAAA,EAAA;;;EAgB8B,CAAA,CAAA;;;;;;;;;EAelC;;;EAMA;;;EAMA;;EAGDA,+BAAAA,CAAAA,gBAAAA,EAAAA,kBAAAA,CAAAA;;EAIA,IAAA,eAAA,GAAA,KAAA,CAAA,QAAA,CAAA;MAAA,OAAA,IAAA,QAAA,CAAA,WAAA,EAAA,gBAAA,CAAA;IAAA,EAAA;IAAA,gBAAA,GAAA,cAAA,CAAA,eAAA;IAAA,QAAA,GAAA,gBAAA;EAQA,IAAA,MAAA,GAAA,QAAA,CAAA,mBAAA,CAAA,gBAAA,CAAA;EAEAC,oBAAAA,CAAAA,KAAAA,CAAAA,WAAAA,CAAAA,UAAAA,aAAAA;IAAAA,OAAAA,WAAAA,GAAAA;MAAAA,OAAAA,SAAAA;IAAAA,IAAAA,QAAAA,CAAAA,SAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,aAAAA,CAAAA,CAAAA;EAAAA,GAAAA,CAAAA,QAAAA,EAAAA,WAAAA,CAAAA,CAAAA,EAAAA;IAAAA,OAAAA,QAAAA,CAAAA,gBAAAA,EAAAA;EAAAA,GAAAA;IAAAA,OAAAA,QAAAA,CAAAA,gBAAAA,EAAAA;EAAAA,EAAAA;;IAaE;IACA;IACAC,QAAAA,CAAAA,UAAAA,CAAAA,gBAAAA,EAAAA;MAAwCC,SAAAA,EAAAA;;EACzC,CAAA,EAAA,CAAA,gBAAA,EAAA,QAAA,CAAA,CAAA,CAAA,CAAA;;;IAIC,MAAA,eAAA,CAAA,gBAAA,EAAA,QAAA,EAAA,kBAAA,CAAA;EACD,CAAA,CAAA;;EAGD,IAAA,WAAA,CAAA;;;;;EACc,CAAA,CAAA,EAAA;;EAQb,CAAA,CAAA;;EAGD,OAAA,CAAA,gBAAA,CAAA,mBAAA,GAAA,QAAA,CAAA,WAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAGD","sourcesContent":["'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"]},"metadata":{},"sourceType":"module"}