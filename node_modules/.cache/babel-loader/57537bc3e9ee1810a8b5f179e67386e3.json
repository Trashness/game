{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/legacy-utils\";\nexport function generateKey(_x) {\n  return _generateKey.apply(this, arguments);\n}\nfunction _generateKey() {\n  _generateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(length) {\n    var _length, bytes, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _length = (length || 256) / 8;\n          bytes = crypto.randomBytes(_length);\n          result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n          return _context.abrupt(\"return\", result);\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _generateKey.apply(this, arguments);\n}\nexport function verifyHmac(_x2, _x3) {\n  return _verifyHmac.apply(this, arguments);\n}\nfunction _verifyHmac() {\n  _verifyHmac = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, key) {\n    var cipherText, iv, hmac, hmacHex, unsigned, chmac, chmacHex;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          cipherText = encoding.hexToArray(payload.data);\n          iv = encoding.hexToArray(payload.iv);\n          hmac = encoding.hexToArray(payload.hmac);\n          hmacHex = encoding.arrayToHex(hmac, false);\n          unsigned = encoding.concatArrays(cipherText, iv);\n          _context2.next = 7;\n          return crypto.hmacSha256Sign(key, unsigned);\n        case 7:\n          chmac = _context2.sent;\n          chmacHex = encoding.arrayToHex(chmac, false);\n          if (!(encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex))) {\n            _context2.next = 11;\n            break;\n          }\n          return _context2.abrupt(\"return\", true);\n        case 11:\n          return _context2.abrupt(\"return\", false);\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _verifyHmac.apply(this, arguments);\n}\nexport function encrypt(_x4, _x5, _x6) {\n  return _encrypt.apply(this, arguments);\n}\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data, key, providedIv) {\n    var _key, ivArrayBuffer, iv, ivHex, contentString, content, cipherText, cipherTextHex, unsigned, hmac, hmacHex;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n          _context3.t0 = providedIv;\n          if (_context3.t0) {\n            _context3.next = 6;\n            break;\n          }\n          _context3.next = 5;\n          return generateKey(128);\n        case 5:\n          _context3.t0 = _context3.sent;\n        case 6:\n          ivArrayBuffer = _context3.t0;\n          iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n          ivHex = encoding.arrayToHex(iv, false);\n          contentString = JSON.stringify(data);\n          content = encoding.utf8ToArray(contentString);\n          _context3.next = 13;\n          return crypto.aesCbcEncrypt(iv, _key, content);\n        case 13:\n          cipherText = _context3.sent;\n          cipherTextHex = encoding.arrayToHex(cipherText, false);\n          unsigned = encoding.concatArrays(cipherText, iv);\n          _context3.next = 18;\n          return crypto.hmacSha256Sign(_key, unsigned);\n        case 18:\n          hmac = _context3.sent;\n          hmacHex = encoding.arrayToHex(hmac, false);\n          return _context3.abrupt(\"return\", {\n            data: cipherTextHex,\n            hmac: hmacHex,\n            iv: ivHex\n          });\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _encrypt.apply(this, arguments);\n}\nexport function decrypt(_x7, _x8) {\n  return _decrypt.apply(this, arguments);\n}\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(payload, key) {\n    var _key, verified, cipherText, iv, buffer, utf8, data;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n          if (_key) {\n            _context4.next = 3;\n            break;\n          }\n          throw new Error(\"Missing key: required for decryption\");\n        case 3:\n          _context4.next = 5;\n          return verifyHmac(payload, _key);\n        case 5:\n          verified = _context4.sent;\n          if (verified) {\n            _context4.next = 8;\n            break;\n          }\n          return _context4.abrupt(\"return\", null);\n        case 8:\n          cipherText = encoding.hexToArray(payload.data);\n          iv = encoding.hexToArray(payload.iv);\n          _context4.next = 12;\n          return crypto.aesCbcDecrypt(iv, _key, cipherText);\n        case 12:\n          buffer = _context4.sent;\n          utf8 = encoding.arrayToUtf8(buffer);\n          _context4.prev = 14;\n          data = JSON.parse(utf8);\n          _context4.next = 21;\n          break;\n        case 18:\n          _context4.prev = 18;\n          _context4.t0 = _context4[\"catch\"](14);\n          return _context4.abrupt(\"return\", null);\n        case 21:\n          return _context4.abrupt(\"return\", data);\n        case 22:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[14, 18]]);\n  }));\n  return _decrypt.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer, } from \"@walletconnect/legacy-utils\";\nexport async function generateKey(length) {\n    const _length = (length || 256) / 8;\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n}\nexport async function verifyHmac(payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = await crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n        return true;\n    }\n    return false;\n}\nexport async function encrypt(data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    const ivArrayBuffer = providedIv || (await generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n        data: cipherTextHex,\n        hmac: hmacHex,\n        iv: ivHex,\n    };\n}\nexport async function decrypt(payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    if (!_key) {\n        throw new Error(\"Missing key: required for decryption\");\n    }\n    const verified = await verifyHmac(payload, _key);\n    if (!verified) {\n        return null;\n    }\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n    try {\n        data = JSON.parse(utf8);\n    }\n    catch (error) {\n        return null;\n    }\n    return data;\n}\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}