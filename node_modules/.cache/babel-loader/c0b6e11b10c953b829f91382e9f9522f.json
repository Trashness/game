{"ast":null,"code":"import _construct from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _objectSpread from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldGet from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nvar _cache, _hooks;\nvar InjectorService_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { ancestorsOf, catchError, classOf, deepClone, deepMerge, Hooks, isArray, isClass, isFunction, isInheritedFrom, isPromise, Metadata, nameOf, Store } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { Configuration } from \"../decorators/configuration.js\";\nimport { Injectable } from \"../decorators/injectable.js\";\nimport { Container } from \"../domain/Container.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\nimport { LocalsContainer } from \"../domain/LocalsContainer.js\";\nimport { Provider } from \"../domain/Provider.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { InjectionError } from \"../errors/InjectionError.js\";\nimport { UndefinedTokenError } from \"../errors/UndefinedTokenError.js\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { createContainer } from \"../utils/createContainer.js\";\nimport { resolveControllers } from \"../utils/resolveControllers.js\";\nimport { DIConfiguration } from \"./DIConfiguration.js\";\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/di\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services are imported, you can load InjectorService.\n * const injector = new InjectorService()\n *\n * await injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n */\nvar InjectorService = InjectorService_1 = (_cache = /*#__PURE__*/new WeakMap(), _hooks = /*#__PURE__*/new WeakMap(), /*#__PURE__*/function (_Container) {\n  _inherits(InjectorService, _Container);\n  var _super = _createSuper(InjectorService);\n  function InjectorService() {\n    var _this;\n    _classCallCheck(this, InjectorService);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"settings\", new DIConfiguration());\n    _defineProperty(_assertThisInitialized(_this), \"logger\", console);\n    _defineProperty(_assertThisInitialized(_this), \"resolvedConfiguration\", false);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _cache, {\n      writable: true,\n      value: new LocalsContainer()\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hooks, {\n      writable: true,\n      value: new Hooks()\n    });\n    _classPrivateFieldGet(_assertThisInitialized(_this), _cache).set(InjectorService_1, _assertThisInitialized(_this));\n    return _this;\n  }\n  _createClass(InjectorService, [{\n    key: \"resolvers\",\n    get: function get() {\n      return this.settings.resolvers;\n    }\n  }, {\n    key: \"scopes\",\n    get: function get() {\n      return this.settings.scopes || {};\n    }\n    /**\n     * Retrieve default scope for a given provider.\n     * @param provider\n     */\n  }, {\n    key: \"scopeOf\",\n    value: function scopeOf(provider) {\n      return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n    }\n    /**\n     * Return a list of instance build by the injector.\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return _toConsumableArray(_classPrivateFieldGet(this, _cache).values());\n    }\n    /**\n     * Get a service or factory already constructed from his symbol or class.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services\";\n     *\n     * class OtherService {\n     *      constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.get<MyService>(MyService);\n     *      }\n     * }\n     * ```\n     *\n     * @param token The class or symbol registered in InjectorService.\n     * @param options\n     * @returns {boolean}\n     */\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var instance = this.getInstance(token);\n      if (instance !== undefined) {\n        return instance;\n      }\n      if (!this.hasProvider(token)) {\n        var _iterator = _createForOfIteratorHelper(this.resolvers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var resolver = _step.value;\n            var result = resolver.get(token, options);\n            if (result !== undefined) {\n              return result;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * Return all instance of the same provider type\n     * @param type\n     * @param locals\n     * @param options\n     */\n  }, {\n    key: \"getMany\",\n    value: function getMany(type, locals, options) {\n      var _this2 = this;\n      return this.getProviders(type).map(function (provider) {\n        return _this2.invoke(provider.token, locals, options);\n      });\n    }\n    /**\n     * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n     * @returns {boolean}\n     * @param token\n     */\n  }, {\n    key: \"has\",\n    value: function has(token) {\n      return _classPrivateFieldGet(this, _cache).get(token) !== undefined;\n    }\n    /**\n     * Invoke the class and inject all services that required by the class constructor.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services\";\n     *\n     * class OtherService {\n     *     constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.invoke<MyService>(MyService);\n     *      }\n     *  }\n     * ```\n     *\n     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     * @param options\n     * @returns {T} The class constructed.\n     */\n  }, {\n    key: \"invoke\",\n    value: function invoke(token, locals) {\n      var _this3 = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var instance = locals ? locals.get(token) : undefined;\n      if (instance !== undefined) {\n        return instance;\n      }\n      if (token === Configuration) {\n        return this.settings;\n      }\n      instance = !options.rebuild ? this.getInstance(token) : undefined;\n      if (instance != undefined) {\n        return instance;\n      }\n      if (token === DI_PARAM_OPTIONS) {\n        return {};\n      }\n      var provider = this.ensureProvider(token);\n      if (!provider || options.rebuild) {\n        instance = this.resolve(token, locals, options);\n        if (this.hasProvider(token)) {\n          _classPrivateFieldGet(this, _cache).set(token, instance);\n        }\n        return instance;\n      }\n      instance = this.resolve(token, locals, options);\n      switch (this.scopeOf(provider)) {\n        case ProviderScope.SINGLETON:\n          if (provider.hooks && !options.rebuild) {\n            this.registerHooks(provider, instance);\n          }\n          if (!provider.isAsync() || !isPromise(instance)) {\n            _classPrivateFieldGet(this, _cache).set(token, instance);\n            return instance;\n          }\n          // store promise to lock token in cache\n          _classPrivateFieldGet(this, _cache).set(token, instance);\n          instance = instance.then(function (instance) {\n            _classPrivateFieldGet(_this3, _cache).set(token, instance);\n            return instance;\n          });\n          return instance;\n        case ProviderScope.REQUEST:\n          if (locals) {\n            locals.set(token, instance);\n            if (provider.hooks && provider.hooks.$onDestroy) {\n              locals.hooks.on(\"$onDestroy\", function () {\n                var _provider$hooks;\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                return (_provider$hooks = provider.hooks).$onDestroy.apply(_provider$hooks, [instance].concat(args));\n              });\n            }\n          }\n          return instance;\n      }\n      return instance;\n    }\n    /**\n     * Build only providers which are asynchronous.\n     */\n  }, {\n    key: \"loadAsync\",\n    value: function () {\n      var _loadAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _iterator2, _step2, _step2$value, provider;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelper(this);\n              _context.prev = 1;\n              _iterator2.s();\n            case 3:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 10;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), provider = _step2$value[1];\n              if (!(!this.has(provider.token) && provider.isAsync())) {\n                _context.next = 8;\n                break;\n              }\n              _context.next = 8;\n              return this.invoke(provider.token);\n            case 8:\n              _context.next = 3;\n              break;\n            case 10:\n              _context.next = 15;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](1);\n              _iterator2.e(_context.t0);\n            case 15:\n              _context.prev = 15;\n              _iterator2.f();\n              return _context.finish(15);\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[1, 12, 15, 18]]);\n      }));\n      function loadAsync() {\n        return _loadAsync.apply(this, arguments);\n      }\n      return loadAsync;\n    }()\n  }, {\n    key: \"loadSync\",\n    value: function loadSync() {\n      var _iterator3 = _createForOfIteratorHelper(this),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            provider = _step3$value[1];\n          if (!this.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n            this.invoke(provider.token);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Boostrap injector from container and resolve configuration.\n     *\n     * @param container\n     */\n  }, {\n    key: \"bootstrap\",\n    value: function bootstrap() {\n      var _this$settings$import,\n        _this4 = this;\n      var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : createContainer();\n      // Clone all providers in the container\n      this.addProviders(container);\n      // Resolve all configuration\n      this.resolveConfiguration();\n      // allow mocking or changing provider instance before loading injector\n      this.settings.imports = (_this$settings$import = this.settings.imports) === null || _this$settings$import === void 0 ? void 0 : _this$settings$import.map(function (meta) {\n        if (\"token\" in meta && \"use\" in meta) {\n          var token = meta.token,\n            use = meta.use;\n          var provider = _this4.getProvider(token);\n          if (provider) {\n            provider.useValue = use;\n            // @ts-ignore\n            provider.useFactory = undefined;\n            // @ts-ignore\n            provider.useAsyncFactory = undefined;\n            // @ts-ignore\n            provider.useClass = undefined;\n            return;\n          }\n        }\n        return meta;\n      }).filter(Boolean);\n      return this;\n    }\n    /**\n     * Load injector from a given module\n     * @param rootModule\n     */\n  }, {\n    key: \"loadModule\",\n    value: function loadModule(rootModule) {\n      this.settings.routes = this.settings.routes.concat(resolveControllers(this.settings));\n      var container = createContainer();\n      container.delete(rootModule);\n      container.addProvider(rootModule, {\n        type: \"server:module\",\n        scope: ProviderScope.SINGLETON\n      });\n      return this.load(container);\n    }\n    /**\n     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.\n     *\n     * @param container\n     */\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var container,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              container = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : createContainer();\n              this.bootstrap(container);\n              // build async and sync provider\n              _context2.next = 4;\n              return this.loadAsync();\n            case 4:\n              // load sync provider\n              this.loadSync();\n              _context2.next = 7;\n              return this.emit(\"$beforeInit\");\n            case 7:\n              _context2.next = 9;\n              return this.emit(\"$onInit\");\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function load() {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n    /**\n     * Load all configurations registered on providers\n     */\n  }, {\n    key: \"resolveConfiguration\",\n    value: function resolveConfiguration() {\n      var _this5 = this;\n      if (this.resolvedConfiguration) {\n        return;\n      }\n      var mergedConfiguration = new Map();\n      _get(_getPrototypeOf(InjectorService.prototype), \"forEach\", this).call(this, function (provider) {\n        if (provider.configuration && provider.type !== \"server:module\") {\n          Object.entries(provider.configuration).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n            if (![\"resolvers\", \"mount\", \"imports\"].includes(key)) {\n              value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);\n              mergedConfiguration.set(key, value);\n            }\n          });\n        }\n        if (provider.resolvers) {\n          _this5.settings.resolvers = _this5.settings.resolvers.concat(provider.resolvers);\n        }\n      });\n      mergedConfiguration.forEach(function (value, key) {\n        _this5.settings.set(key, deepMerge(value, _this5.settings.get(key)));\n      });\n      this.resolvedConfiguration = true;\n    }\n    /**\n     *\n     * @param instance\n     * @param locals\n     * @param options\n     */\n  }, {\n    key: \"bindInjectableProperties\",\n    value: function bindInjectableProperties(instance, locals, options) {\n      var _this6 = this;\n      var properties = ancestorsOf(classOf(instance)).reduce(function (properties, target) {\n        var store = Store.from(target);\n        return _objectSpread(_objectSpread({}, properties), store.get(INJECTABLE_PROP) || {});\n      }, {});\n      Object.values(properties).forEach(function (definition) {\n        switch (definition.bindingType) {\n          case InjectablePropertyType.PROPERTY:\n            _this6.bindProperty(instance, definition, locals, options);\n            break;\n          case InjectablePropertyType.CONSTANT:\n            _this6.bindConstant(instance, definition);\n            break;\n          case InjectablePropertyType.VALUE:\n            _this6.bindValue(instance, definition);\n            break;\n          case InjectablePropertyType.INTERCEPTOR:\n            _this6.bindInterceptor(instance, definition);\n            break;\n        }\n      });\n    }\n    /**\n     * Create an injectable property.\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     * @param resolver\n     * @param options\n     * @param locals\n     * @param invokeOptions\n     */\n  }, {\n    key: \"bindProperty\",\n    value: function bindProperty(instance, _ref3, locals, invokeOptions) {\n      var propertyKey = _ref3.propertyKey,\n        resolver = _ref3.resolver,\n        _ref3$options = _ref3.options,\n        options = _ref3$options === void 0 ? {} : _ref3$options;\n      var get;\n      get = resolver(this, locals, _objectSpread(_objectSpread({}, invokeOptions), {}, {\n        options: options\n      }));\n      catchError(function () {\n        return Object.defineProperty(instance, propertyKey, {\n          get: get\n        });\n      });\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n  }, {\n    key: \"bindValue\",\n    value: function bindValue(instance, _ref4) {\n      var _this7 = this;\n      var propertyKey = _ref4.propertyKey,\n        expression = _ref4.expression,\n        defaultValue = _ref4.defaultValue;\n      var descriptor = {\n        get: function get() {\n          return _this7.settings.get(expression) || defaultValue;\n        },\n        set: function set(value) {\n          return _this7.settings.set(expression, value);\n        },\n        enumerable: true,\n        configurable: true\n      };\n      catchError(function () {\n        return Object.defineProperty(instance, propertyKey, descriptor);\n      });\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n  }, {\n    key: \"bindConstant\",\n    value: function bindConstant(instance, _ref5) {\n      var _this8 = this;\n      var propertyKey = _ref5.propertyKey,\n        expression = _ref5.expression,\n        defaultValue = _ref5.defaultValue;\n      var bean;\n      var get = function get() {\n        if (bean !== undefined) {\n          return bean;\n        }\n        var value = _this8.settings.get(expression, defaultValue);\n        bean = Object.freeze(deepClone(value));\n        return bean;\n      };\n      var descriptor = {\n        get: get,\n        enumerable: true,\n        configurable: true\n      };\n      catchError(function () {\n        return Object.defineProperty(instance, propertyKey, descriptor);\n      });\n    }\n    /**\n     *\n     * @param instance\n     * @param propertyKey\n     * @param useType\n     * @param options\n     */\n  }, {\n    key: \"bindInterceptor\",\n    value: function bindInterceptor(instance, _ref6) {\n      var _this9 = this;\n      var propertyKey = _ref6.propertyKey,\n        useType = _ref6.useType,\n        options = _ref6.options;\n      var target = classOf(instance);\n      var originalMethod = instance[propertyKey];\n      instance[propertyKey] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        var next = function next(err) {\n          if (!err) {\n            return originalMethod.apply(instance, args);\n          }\n          throw err;\n        };\n        var context = {\n          target: target,\n          propertyKey: propertyKey,\n          args: args,\n          options: options,\n          next: next\n        };\n        var interceptor = _this9.get(useType);\n        return interceptor.intercept(_objectSpread(_objectSpread({}, context), {}, {\n          options: options\n        }), next);\n      };\n    }\n  }, {\n    key: \"lazyInvoke\",\n    value: function () {\n      var _lazyInvoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {\n        var instance, _instance;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              instance = this.getInstance(token);\n              if (instance) {\n                _context3.next = 8;\n                break;\n              }\n              _context3.next = 4;\n              return this.invoke(token);\n            case 4:\n              instance = _context3.sent;\n              if (!isFunction((_instance = instance) === null || _instance === void 0 ? void 0 : _instance.$onInit)) {\n                _context3.next = 8;\n                break;\n              }\n              _context3.next = 8;\n              return instance.$onInit();\n            case 8:\n              return _context3.abrupt(\"return\", instance);\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function lazyInvoke(_x) {\n        return _lazyInvoke.apply(this, arguments);\n      }\n      return lazyInvoke;\n    }()\n    /**\n     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n     * @param eventName The event name to emit at all services.\n     * @param args List of the parameters to give to each service.\n     * @returns {Promise<any[]>} A list of promises.\n     */\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(eventName) {\n        var _len3,\n          args,\n          _key3,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              for (_len3 = _args4.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                args[_key3 - 1] = _args4[_key3];\n              }\n              return _context4.abrupt(\"return\", _classPrivateFieldGet(this, _hooks).asyncEmit(eventName, args));\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function emit(_x2) {\n        return _emit.apply(this, arguments);\n      }\n      return emit;\n    }()\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n  }, {\n    key: \"alter\",\n    value: function alter(eventName, value) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n      return _classPrivateFieldGet(this, _hooks).alter(eventName, value, args);\n    }\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n  }, {\n    key: \"alterAsync\",\n    value: function () {\n      var _alterAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(eventName, value) {\n        var _len5,\n          args,\n          _key5,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              for (_len5 = _args5.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n                args[_key5 - 2] = _args5[_key5];\n              }\n              return _context5.abrupt(\"return\", _classPrivateFieldGet(this, _hooks).asyncAlter(eventName, value, args));\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function alterAsync(_x3, _x4) {\n        return _alterAsync.apply(this, arguments);\n      }\n      return alterAsync;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function () {\n      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.emit(\"$onDestroy\");\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function destroy() {\n        return _destroy.apply(this, arguments);\n      }\n      return destroy;\n    }()\n  }, {\n    key: \"ensureProvider\",\n    value: function ensureProvider(token) {\n      if (!this.hasProvider(token) && GlobalProviders.has(token)) {\n        this.addProvider(token);\n      }\n      return this.getProvider(token);\n    }\n  }, {\n    key: \"getInstance\",\n    value: function getInstance(token) {\n      return _classPrivateFieldGet(this, _cache).get(token);\n    }\n    /**\n     * Invoke a class method and inject service.\n     *\n     * #### IInjectableMethod options\n     *\n     * * **target**: Optional. The class instance.\n     * * **methodName**: `string` Optional. The method name.\n     * * **designParamTypes**: `any[]` Optional. List of injectable types.\n     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     *\n     * #### Example\n     *\n     * @param target\n     * @param locals\n     * @param options\n     * @private\n     */\n  }, {\n    key: \"resolve\",\n    value: function resolve(target) {\n      var _this10 = this;\n      var locals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LocalsContainer();\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var resolvedOpts = this.mapInvokeOptions(target, locals, options);\n      var token = resolvedOpts.token,\n        deps = resolvedOpts.deps,\n        construct = resolvedOpts.construct,\n        imports = resolvedOpts.imports,\n        provider = resolvedOpts.provider;\n      if (provider) {\n        GlobalProviders.onInvoke(provider, locals, _objectSpread(_objectSpread({}, resolvedOpts), {}, {\n          injector: this\n        }));\n      }\n      var instance;\n      var currentDependency = false;\n      try {\n        var invokeDependency = function invokeDependency(parent) {\n          return function (token, index) {\n            currentDependency = {\n              token: token,\n              index: index,\n              deps: deps\n            };\n            if (token !== DI_PARAM_OPTIONS) {\n              var _provider$store;\n              var _options = provider === null || provider === void 0 ? void 0 : (_provider$store = provider.store) === null || _provider$store === void 0 ? void 0 : _provider$store.get(\"\".concat(DI_PARAM_OPTIONS, \":\").concat(index));\n              locals.set(DI_PARAM_OPTIONS, _options || {});\n            }\n            if (isArray(token)) {\n              return _this10.getMany(token[0], locals, options);\n            }\n            return isInheritedFrom(token, Provider, 1) ? provider : _this10.invoke(token, locals, {\n              parent: parent\n            });\n          };\n        };\n        // Invoke manually imported providers\n        imports.forEach(invokeDependency());\n        // Inject dependencies\n        var services = deps.map(invokeDependency(token));\n        currentDependency = false;\n        instance = construct(services);\n      } catch (error) {\n        InjectionError.throwInjectorError(token, currentDependency, error);\n      }\n      if (instance === undefined) {\n        throw new InjectionError(token, \"Unable to create new instance from undefined value. Check your provider declaration for \".concat(nameOf(token)));\n      }\n      if (instance && isClass(classOf(instance))) {\n        this.bindInjectableProperties(instance, locals, options);\n      }\n      return instance;\n    }\n    /**\n     * Create options to invoke a provider or class.\n     * @param token\n     * @param locals\n     * @param options\n     */\n  }, {\n    key: \"mapInvokeOptions\",\n    value: function mapInvokeOptions(token, locals, options) {\n      var imports = options.imports;\n      var deps = options.deps;\n      var scope = options.scope;\n      var construct;\n      if (!token) {\n        throw new UndefinedTokenError();\n      }\n      var provider;\n      if (!this.hasProvider(token)) {\n        provider = new Provider(token);\n        this.resolvers.forEach(function (resolver) {\n          var result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));\n          if (result !== undefined) {\n            provider.useFactory = function () {\n              return result;\n            };\n          }\n        });\n      } else {\n        provider = this.getProvider(token);\n      }\n      scope = scope || this.scopeOf(provider);\n      deps = deps || provider.deps;\n      imports = imports || provider.imports;\n      if (provider.useValue !== undefined) {\n        construct = function construct() {\n          return isFunction(provider.useValue) ? provider.useValue() : provider.useValue;\n        };\n      } else if (provider.useFactory) {\n        construct = function construct(deps) {\n          var _provider;\n          return (_provider = provider).useFactory.apply(_provider, _toConsumableArray(deps));\n        };\n      } else if (provider.useAsyncFactory) {\n        construct = /*#__PURE__*/function () {\n          var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(deps) {\n            var _provider2;\n            return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n              while (1) switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.next = 2;\n                  return Promise.all(deps);\n                case 2:\n                  deps = _context7.sent;\n                  return _context7.abrupt(\"return\", (_provider2 = provider).useAsyncFactory.apply(_provider2, _toConsumableArray(deps)));\n                case 4:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }, _callee7);\n          }));\n          return function construct(_x5) {\n            return _ref7.apply(this, arguments);\n          };\n        }();\n      } else {\n        // useClass\n        deps = deps || Metadata.getParamTypes(provider.useClass);\n        construct = function construct(deps) {\n          return _construct(provider.useClass, _toConsumableArray(deps));\n        };\n      }\n      return {\n        token: token,\n        scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n        deps: deps || [],\n        imports: imports || [],\n        construct: construct,\n        provider: provider\n      };\n    }\n  }, {\n    key: \"registerHooks\",\n    value: function registerHooks(provider, instance) {\n      var _this11 = this;\n      if (provider.hooks) {\n        Object.entries(provider.hooks).forEach(function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n            event = _ref9[0],\n            cb = _ref9[1];\n          var callback = function callback() {\n            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n              args[_key6] = arguments[_key6];\n            }\n            return cb.apply(void 0, [_this11.get(provider.token) || instance].concat(args));\n          };\n          _classPrivateFieldGet(_this11, _hooks).on(event, callback);\n        });\n      }\n    }\n  }]);\n  return InjectorService;\n}(Container));\nInjectorService = InjectorService_1 = __decorate([Injectable({\n  scope: ProviderScope.SINGLETON,\n  global: true\n}), __metadata(\"design:paramtypes\", [])], InjectorService);\nexport { InjectorService };","map":{"version":3,"sources":["../../../src/services/InjectorService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var InjectorService_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { ancestorsOf, catchError, classOf, deepClone, deepMerge, Hooks, isArray, isClass, isFunction, isInheritedFrom, isPromise, Metadata, nameOf, Store } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { Configuration } from \"../decorators/configuration.js\";\nimport { Injectable } from \"../decorators/injectable.js\";\nimport { Container } from \"../domain/Container.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\nimport { LocalsContainer } from \"../domain/LocalsContainer.js\";\nimport { Provider } from \"../domain/Provider.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { InjectionError } from \"../errors/InjectionError.js\";\nimport { UndefinedTokenError } from \"../errors/UndefinedTokenError.js\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { createContainer } from \"../utils/createContainer.js\";\nimport { resolveControllers } from \"../utils/resolveControllers.js\";\nimport { DIConfiguration } from \"./DIConfiguration.js\";\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/di\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services are imported, you can load InjectorService.\n * const injector = new InjectorService()\n *\n * await injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n */\nlet InjectorService = InjectorService_1 = class InjectorService extends Container {\n    settings = new DIConfiguration();\n    logger = console;\n    resolvedConfiguration = false;\n    #cache = new LocalsContainer();\n    #hooks = new Hooks();\n    constructor() {\n        super();\n        this.#cache.set(InjectorService_1, this);\n    }\n    get resolvers() {\n        return this.settings.resolvers;\n    }\n    get scopes() {\n        return this.settings.scopes || {};\n    }\n    /**\n     * Retrieve default scope for a given provider.\n     * @param provider\n     */\n    scopeOf(provider) {\n        return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n    }\n    /**\n     * Return a list of instance build by the injector.\n     */\n    toArray() {\n        return [...this.#cache.values()];\n    }\n    /**\n     * Get a service or factory already constructed from his symbol or class.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services\";\n     *\n     * class OtherService {\n     *      constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.get<MyService>(MyService);\n     *      }\n     * }\n     * ```\n     *\n     * @param token The class or symbol registered in InjectorService.\n     * @param options\n     * @returns {boolean}\n     */\n    get(token, options = {}) {\n        const instance = this.getInstance(token);\n        if (instance !== undefined) {\n            return instance;\n        }\n        if (!this.hasProvider(token)) {\n            for (const resolver of this.resolvers) {\n                const result = resolver.get(token, options);\n                if (result !== undefined) {\n                    return result;\n                }\n            }\n        }\n    }\n    /**\n     * Return all instance of the same provider type\n     * @param type\n     * @param locals\n     * @param options\n     */\n    getMany(type, locals, options) {\n        return this.getProviders(type).map((provider) => this.invoke(provider.token, locals, options));\n    }\n    /**\n     * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n     * @returns {boolean}\n     * @param token\n     */\n    has(token) {\n        return this.#cache.get(token) !== undefined;\n    }\n    /**\n     * Invoke the class and inject all services that required by the class constructor.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services\";\n     *\n     * class OtherService {\n     *     constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.invoke<MyService>(MyService);\n     *      }\n     *  }\n     * ```\n     *\n     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     * @param options\n     * @returns {T} The class constructed.\n     */\n    invoke(token, locals, options = {}) {\n        let instance = locals ? locals.get(token) : undefined;\n        if (instance !== undefined) {\n            return instance;\n        }\n        if (token === Configuration) {\n            return this.settings;\n        }\n        instance = !options.rebuild ? this.getInstance(token) : undefined;\n        if (instance != undefined) {\n            return instance;\n        }\n        if (token === DI_PARAM_OPTIONS) {\n            return {};\n        }\n        const provider = this.ensureProvider(token);\n        if (!provider || options.rebuild) {\n            instance = this.resolve(token, locals, options);\n            if (this.hasProvider(token)) {\n                this.#cache.set(token, instance);\n            }\n            return instance;\n        }\n        instance = this.resolve(token, locals, options);\n        switch (this.scopeOf(provider)) {\n            case ProviderScope.SINGLETON:\n                if (provider.hooks && !options.rebuild) {\n                    this.registerHooks(provider, instance);\n                }\n                if (!provider.isAsync() || !isPromise(instance)) {\n                    this.#cache.set(token, instance);\n                    return instance;\n                }\n                // store promise to lock token in cache\n                this.#cache.set(token, instance);\n                instance = instance.then((instance) => {\n                    this.#cache.set(token, instance);\n                    return instance;\n                });\n                return instance;\n            case ProviderScope.REQUEST:\n                if (locals) {\n                    locals.set(token, instance);\n                    if (provider.hooks && provider.hooks.$onDestroy) {\n                        locals.hooks.on(\"$onDestroy\", (...args) => provider.hooks.$onDestroy(instance, ...args));\n                    }\n                }\n                return instance;\n        }\n        return instance;\n    }\n    /**\n     * Build only providers which are asynchronous.\n     */\n    async loadAsync() {\n        for (const [, provider] of this) {\n            if (!this.has(provider.token) && provider.isAsync()) {\n                await this.invoke(provider.token);\n            }\n        }\n    }\n    loadSync() {\n        for (const [, provider] of this) {\n            if (!this.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n                this.invoke(provider.token);\n            }\n        }\n    }\n    /**\n     * Boostrap injector from container and resolve configuration.\n     *\n     * @param container\n     */\n    bootstrap(container = createContainer()) {\n        // Clone all providers in the container\n        this.addProviders(container);\n        // Resolve all configuration\n        this.resolveConfiguration();\n        // allow mocking or changing provider instance before loading injector\n        this.settings.imports = this.settings.imports\n            ?.map((meta) => {\n            if (\"token\" in meta && \"use\" in meta) {\n                const { token, use } = meta;\n                const provider = this.getProvider(token);\n                if (provider) {\n                    provider.useValue = use;\n                    // @ts-ignore\n                    provider.useFactory = undefined;\n                    // @ts-ignore\n                    provider.useAsyncFactory = undefined;\n                    // @ts-ignore\n                    provider.useClass = undefined;\n                    return;\n                }\n            }\n            return meta;\n        })\n            .filter(Boolean);\n        return this;\n    }\n    /**\n     * Load injector from a given module\n     * @param rootModule\n     */\n    loadModule(rootModule) {\n        this.settings.routes = this.settings.routes.concat(resolveControllers(this.settings));\n        const container = createContainer();\n        container.delete(rootModule);\n        container.addProvider(rootModule, {\n            type: \"server:module\",\n            scope: ProviderScope.SINGLETON\n        });\n        return this.load(container);\n    }\n    /**\n     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.\n     *\n     * @param container\n     */\n    async load(container = createContainer()) {\n        this.bootstrap(container);\n        // build async and sync provider\n        await this.loadAsync();\n        // load sync provider\n        this.loadSync();\n        await this.emit(\"$beforeInit\");\n        await this.emit(\"$onInit\");\n    }\n    /**\n     * Load all configurations registered on providers\n     */\n    resolveConfiguration() {\n        if (this.resolvedConfiguration) {\n            return;\n        }\n        const mergedConfiguration = new Map();\n        super.forEach((provider) => {\n            if (provider.configuration && provider.type !== \"server:module\") {\n                Object.entries(provider.configuration).forEach(([key, value]) => {\n                    if (![\"resolvers\", \"mount\", \"imports\"].includes(key)) {\n                        value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);\n                        mergedConfiguration.set(key, value);\n                    }\n                });\n            }\n            if (provider.resolvers) {\n                this.settings.resolvers = this.settings.resolvers.concat(provider.resolvers);\n            }\n        });\n        mergedConfiguration.forEach((value, key) => {\n            this.settings.set(key, deepMerge(value, this.settings.get(key)));\n        });\n        this.resolvedConfiguration = true;\n    }\n    /**\n     *\n     * @param instance\n     * @param locals\n     * @param options\n     */\n    bindInjectableProperties(instance, locals, options) {\n        const properties = ancestorsOf(classOf(instance)).reduce((properties, target) => {\n            const store = Store.from(target);\n            return {\n                ...properties,\n                ...(store.get(INJECTABLE_PROP) || {})\n            };\n        }, {});\n        Object.values(properties).forEach((definition) => {\n            switch (definition.bindingType) {\n                case InjectablePropertyType.PROPERTY:\n                    this.bindProperty(instance, definition, locals, options);\n                    break;\n                case InjectablePropertyType.CONSTANT:\n                    this.bindConstant(instance, definition);\n                    break;\n                case InjectablePropertyType.VALUE:\n                    this.bindValue(instance, definition);\n                    break;\n                case InjectablePropertyType.INTERCEPTOR:\n                    this.bindInterceptor(instance, definition);\n                    break;\n            }\n        });\n    }\n    /**\n     * Create an injectable property.\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     * @param resolver\n     * @param options\n     * @param locals\n     * @param invokeOptions\n     */\n    bindProperty(instance, { propertyKey, resolver, options = {} }, locals, invokeOptions) {\n        let get;\n        get = resolver(this, locals, { ...invokeOptions, options });\n        catchError(() => Object.defineProperty(instance, propertyKey, {\n            get\n        }));\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n    bindValue(instance, { propertyKey, expression, defaultValue }) {\n        const descriptor = {\n            get: () => this.settings.get(expression) || defaultValue,\n            set: (value) => this.settings.set(expression, value),\n            enumerable: true,\n            configurable: true\n        };\n        catchError(() => Object.defineProperty(instance, propertyKey, descriptor));\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n    bindConstant(instance, { propertyKey, expression, defaultValue }) {\n        let bean;\n        const get = () => {\n            if (bean !== undefined) {\n                return bean;\n            }\n            const value = this.settings.get(expression, defaultValue);\n            bean = Object.freeze(deepClone(value));\n            return bean;\n        };\n        const descriptor = {\n            get,\n            enumerable: true,\n            configurable: true\n        };\n        catchError(() => Object.defineProperty(instance, propertyKey, descriptor));\n    }\n    /**\n     *\n     * @param instance\n     * @param propertyKey\n     * @param useType\n     * @param options\n     */\n    bindInterceptor(instance, { propertyKey, useType, options }) {\n        const target = classOf(instance);\n        const originalMethod = instance[propertyKey];\n        instance[propertyKey] = (...args) => {\n            const next = (err) => {\n                if (!err) {\n                    return originalMethod.apply(instance, args);\n                }\n                throw err;\n            };\n            const context = {\n                target,\n                propertyKey,\n                args,\n                options,\n                next\n            };\n            const interceptor = this.get(useType);\n            return interceptor.intercept({\n                ...context,\n                options\n            }, next);\n        };\n    }\n    async lazyInvoke(token) {\n        let instance = this.getInstance(token);\n        if (!instance) {\n            instance = await this.invoke(token);\n            if (isFunction(instance?.$onInit)) {\n                await instance.$onInit();\n            }\n        }\n        return instance;\n    }\n    /**\n     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n     * @param eventName The event name to emit at all services.\n     * @param args List of the parameters to give to each service.\n     * @returns {Promise<any[]>} A list of promises.\n     */\n    async emit(eventName, ...args) {\n        return this.#hooks.asyncEmit(eventName, args);\n    }\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n    alter(eventName, value, ...args) {\n        return this.#hooks.alter(eventName, value, args);\n    }\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n    async alterAsync(eventName, value, ...args) {\n        return this.#hooks.asyncAlter(eventName, value, args);\n    }\n    async destroy() {\n        await this.emit(\"$onDestroy\");\n    }\n    ensureProvider(token) {\n        if (!this.hasProvider(token) && GlobalProviders.has(token)) {\n            this.addProvider(token);\n        }\n        return this.getProvider(token);\n    }\n    getInstance(token) {\n        return this.#cache.get(token);\n    }\n    /**\n     * Invoke a class method and inject service.\n     *\n     * #### IInjectableMethod options\n     *\n     * * **target**: Optional. The class instance.\n     * * **methodName**: `string` Optional. The method name.\n     * * **designParamTypes**: `any[]` Optional. List of injectable types.\n     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     *\n     * #### Example\n     *\n     * @param target\n     * @param locals\n     * @param options\n     * @private\n     */\n    resolve(target, locals = new LocalsContainer(), options = {}) {\n        const resolvedOpts = this.mapInvokeOptions(target, locals, options);\n        const { token, deps, construct, imports, provider } = resolvedOpts;\n        if (provider) {\n            GlobalProviders.onInvoke(provider, locals, { ...resolvedOpts, injector: this });\n        }\n        let instance;\n        let currentDependency = false;\n        try {\n            const invokeDependency = (parent) => (token, index) => {\n                currentDependency = { token, index, deps };\n                if (token !== DI_PARAM_OPTIONS) {\n                    const options = provider?.store?.get(`${DI_PARAM_OPTIONS}:${index}`);\n                    locals.set(DI_PARAM_OPTIONS, options || {});\n                }\n                if (isArray(token)) {\n                    return this.getMany(token[0], locals, options);\n                }\n                return isInheritedFrom(token, Provider, 1) ? provider : this.invoke(token, locals, { parent });\n            };\n            // Invoke manually imported providers\n            imports.forEach(invokeDependency());\n            // Inject dependencies\n            const services = deps.map(invokeDependency(token));\n            currentDependency = false;\n            instance = construct(services);\n        }\n        catch (error) {\n            InjectionError.throwInjectorError(token, currentDependency, error);\n        }\n        if (instance === undefined) {\n            throw new InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`);\n        }\n        if (instance && isClass(classOf(instance))) {\n            this.bindInjectableProperties(instance, locals, options);\n        }\n        return instance;\n    }\n    /**\n     * Create options to invoke a provider or class.\n     * @param token\n     * @param locals\n     * @param options\n     */\n    mapInvokeOptions(token, locals, options) {\n        let imports = options.imports;\n        let deps = options.deps;\n        let scope = options.scope;\n        let construct;\n        if (!token) {\n            throw new UndefinedTokenError();\n        }\n        let provider;\n        if (!this.hasProvider(token)) {\n            provider = new Provider(token);\n            this.resolvers.forEach((resolver) => {\n                const result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));\n                if (result !== undefined) {\n                    provider.useFactory = () => result;\n                }\n            });\n        }\n        else {\n            provider = this.getProvider(token);\n        }\n        scope = scope || this.scopeOf(provider);\n        deps = deps || provider.deps;\n        imports = imports || provider.imports;\n        if (provider.useValue !== undefined) {\n            construct = () => (isFunction(provider.useValue) ? provider.useValue() : provider.useValue);\n        }\n        else if (provider.useFactory) {\n            construct = (deps) => provider.useFactory(...deps);\n        }\n        else if (provider.useAsyncFactory) {\n            construct = async (deps) => {\n                deps = await Promise.all(deps);\n                return provider.useAsyncFactory(...deps);\n            };\n        }\n        else {\n            // useClass\n            deps = deps || Metadata.getParamTypes(provider.useClass);\n            construct = (deps) => new provider.useClass(...deps);\n        }\n        return {\n            token,\n            scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n            deps: deps || [],\n            imports: imports || [],\n            construct,\n            provider\n        };\n    }\n    registerHooks(provider, instance) {\n        if (provider.hooks) {\n            Object.entries(provider.hooks).forEach(([event, cb]) => {\n                const callback = (...args) => cb(this.get(provider.token) || instance, ...args);\n                this.#hooks.on(event, callback);\n            });\n        }\n    }\n};\nInjectorService = InjectorService_1 = __decorate([\n    Injectable({\n        scope: ProviderScope.SINGLETON,\n        global: true\n    }),\n    __metadata(\"design:paramtypes\", [])\n], InjectorService);\nexport { InjectorService };\n//# sourceMappingURL=InjectorService.js.map"]},"metadata":{},"sourceType":"module"}