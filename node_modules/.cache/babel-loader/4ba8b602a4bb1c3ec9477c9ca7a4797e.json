{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nexport var Event = /*#__PURE__*/function () {\n  function Event() {\n    _classCallCheck(this, Event);\n    this._listeners = new Set();\n    this._effects = new Set();\n  }\n  _createClass(Event, [{\n    key: \"emit\",\n    value: function emit(data) {\n      for (var _i = 0, _Array$from = Array.from(this._listeners); _i < _Array$from.length; _i++) {\n        var listener = _Array$from[_i];\n        void this._trigger(listener, data);\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(callback) {\n      var _this = this;\n      this._listeners.add(callback);\n      if (this.listenerCount() === 1) {\n        this._runEffects();\n      }\n      return function () {\n        return _this.off(callback);\n      };\n    }\n  }, {\n    key: \"off\",\n    value: function off(callback) {\n      this._listeners.delete(callback);\n      if (this.listenerCount() === 0) {\n        this._cleanupEffects();\n      }\n    }\n  }, {\n    key: \"listenerCount\",\n    value: function listenerCount() {\n      return this._listeners.size;\n    }\n  }, {\n    key: \"addEffect\",\n    value: function addEffect(effect) {\n      var _this2 = this;\n      var handle = {\n        effect: effect,\n        cleanup: undefined\n      };\n      if (this.listenerCount() > 0) {\n        var cleanup = handle.effect();\n        if (typeof cleanup === 'function') {\n          handle.cleanup = cleanup;\n        }\n      }\n      this._effects.add(handle);\n      return function () {\n        var _a;\n        // eslint-disable-next-line no-unused-expressions\n        (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n        _this2._effects.delete(handle);\n      };\n    }\n  }, {\n    key: \"_trigger\",\n    value: function () {\n      var _trigger2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(listener, data) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return waitImmediate();\n            case 3:\n              // Acts like setImmediate but preserves the stack-trace.\n              listener(data);\n              _context.next = 9;\n              break;\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n              // Stop error propagation.\n              throwUnhandledRejection(_context.t0);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 6]]);\n      }));\n      function _trigger(_x, _x2) {\n        return _trigger2.apply(this, arguments);\n      }\n      return _trigger;\n    }()\n  }, {\n    key: \"_runEffects\",\n    value: function _runEffects() {\n      for (var _i2 = 0, _Array$from2 = Array.from(this._effects); _i2 < _Array$from2.length; _i2++) {\n        var handle = _Array$from2[_i2];\n        var cleanup = handle.effect();\n        if (typeof cleanup === 'function') {\n          handle.cleanup = cleanup;\n        }\n      }\n    }\n  }, {\n    key: \"_cleanupEffects\",\n    value: function _cleanupEffects() {\n      var _a;\n      for (var _i3 = 0, _Array$from3 = Array.from(this._effects); _i3 < _Array$from3.length; _i3++) {\n        var handle = _Array$from3[_i3];\n        // eslint-disable-next-line no-unused-expressions\n        (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n        handle.cleanup = undefined;\n      }\n    }\n  }]);\n  return Event;\n}();\nfunction throwUnhandledRejection(error) {\n  setTimeout(function () {\n    throw error;\n  });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nvar waitImmediate = function waitImmediate() {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve);\n  });\n};","map":{"version":3,"sources":["../../../../src/helpers/event.ts"],"names":[],"mappings":";;;;AAiBA,WAAa,KAAK;EAAlB,SAAA,MAAA,EAAA;IAAA,eAAA,OAAA,KAAA;IACmB,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAqB;IACzC,IAAA,CAAA,QAAQ,GAAG,IAAI,GAAG,EAAsB;EA0E3D;EAAC,YAAA,CAAA,KAAA;IAAA,GAAA;IAAA,KAAA,EAxEC,SAAA,KAAK,IAAO,EAAA;MACV,SAAA,EAAA,MAAA,WAAA,GAAuB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAA,EAAA,GAAA,WAAA,CAAA,MAAA,EAAA,EAAA,IAAE;QAA/C,IAAM,QAAQ,GAAA,WAAA,CAAA,EAAA;QACjB,KAAK,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC;MACnC;IACH;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,GAAG,QAA2B,EAAA;MAAA,IAAA,KAAA;MAC5B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC;MAE7B,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC,WAAW,EAAE;MACnB;MAED,OAAO;QAAA,OAAM,KAAI,CAAC,GAAG,CAAC,QAAQ,CAAC;MAAA;IACjC;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,IAAI,QAA2B,EAAA;MAC7B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC;MAEhC,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC,eAAe,EAAE;MACvB;IACH;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,cAAA,EAAa;MACX,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI;IAC7B;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,UAAU,MAAc,EAAA;MAAA,IAAA,MAAA;MACtB,IAAM,MAAM,GAAuB;QAAE,MAAM,EAAN,MAAM;QAAE,OAAO,EAAE;MAAS,CAAE;MAEjE,IAAI,IAAI,CAAC,aAAa,EAAE,GAAG,CAAC,EAAE;QAC5B,IAAM,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;QAC/B,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;UACjC,MAAM,CAAC,OAAO,GAAG,OAAO;QACzB;MACF;MAED,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC;MACzB,OAAO,YAAK;;QACV;QACA,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,MAAA,CAAI;QAClB,MAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;MAC9B,CAAC;IACH;EAAC;IAAA,GAAA;IAAA,KAAA;MAAA,IAAA,SAAA,GAAA,iBAAA,eAAA,mBAAA,GAAA,IAAA,CAEO,SAAA,QAAe,QAA2B,EAAE,IAAO;QAAA,OAAA,mBAAA,GAAA,IAAA,UAAA,SAAA,QAAA;UAAA,kBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;YAAA;cAAA,QAAA,CAAA,IAAA;cAAA,QAAA,CAAA,IAAA;cAAA,OAEjD,aAAa,EAAE;YAAA;cAAC;cACtB,QAAQ,CAAC,IAAI,CAAC;cAAA,QAAA,CAAA,IAAA;cAAA;YAAA;cAAA,QAAA,CAAA,IAAA;cAAA,QAAA,CAAA,EAAA,GAAA,QAAA;cAEd;cACA,uBAAuB,CAAA,QAAA,CAAA,EAAA,CAAO;YAAA;YAAA;cAAA,OAAA,QAAA,CAAA,IAAA;UAAA;QAAA,GAAA,OAAA;MAAA,CAEjC;MAAA,SAAA,SAAA,EAAA,EAAA,GAAA;QAAA,OAAA,SAAA,CAAA,KAAA,OAAA,SAAA;MAAA;MAAA,OAAA,QAAA;IAAA;EAAA;IAAA,GAAA;IAAA,KAAA,EAEO,SAAA,YAAA,EAAW;MACjB,SAAA,GAAA,MAAA,YAAA,GAAqB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAA,GAAA,GAAA,YAAA,CAAA,MAAA,EAAA,GAAA,IAAE;QAA3C,IAAM,MAAM,GAAA,YAAA,CAAA,GAAA;QACf,IAAM,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;QAC/B,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;UACjC,MAAM,CAAC,OAAO,GAAG,OAAO;QACzB;MACF;IACH;EAAC;IAAA,GAAA;IAAA,KAAA,EAEO,SAAA,gBAAA,EAAe;;MACrB,SAAA,GAAA,MAAA,YAAA,GAAqB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAA,GAAA,GAAA,YAAA,CAAA,MAAA,EAAA,GAAA,IAAE;QAA3C,IAAM,MAAM,GAAA,YAAA,CAAA,GAAA;QACf;QACA,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,MAAA,CAAI;QAClB,MAAM,CAAC,OAAO,GAAG,SAAS;MAC3B;IACH;EAAC;EAAA,OAAA,KAAA;AAAA;AAGH,SAAS,uBAAuB,CAAC,KAAY,EAAA;EAC3C,UAAU,CAAC,YAAK;IACd,MAAM,KAAK;EACb,CAAC,CAAC;AACJ;AAEA;;AAEG;AACH,IAAM,aAAa,GAAG,SAAhB,aAAa,CAAA;EAAA,OAAS,IAAI,OAAO,CAAC,UAAC,OAAO;IAAA,OAAK,UAAU,CAAC,OAAO,CAAC;EAAA,EAAC;AAAA","sourceRoot":"","sourcesContent":["export class Event {\n    constructor() {\n        this._listeners = new Set();\n        this._effects = new Set();\n    }\n    emit(data) {\n        for (const listener of Array.from(this._listeners)) {\n            void this._trigger(listener, data);\n        }\n    }\n    on(callback) {\n        this._listeners.add(callback);\n        if (this.listenerCount() === 1) {\n            this._runEffects();\n        }\n        return () => this.off(callback);\n    }\n    off(callback) {\n        this._listeners.delete(callback);\n        if (this.listenerCount() === 0) {\n            this._cleanupEffects();\n        }\n    }\n    listenerCount() {\n        return this._listeners.size;\n    }\n    addEffect(effect) {\n        const handle = { effect, cleanup: undefined };\n        if (this.listenerCount() > 0) {\n            const cleanup = handle.effect();\n            if (typeof cleanup === 'function') {\n                handle.cleanup = cleanup;\n            }\n        }\n        this._effects.add(handle);\n        return () => {\n            var _a;\n            // eslint-disable-next-line no-unused-expressions\n            (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n            this._effects.delete(handle);\n        };\n    }\n    async _trigger(listener, data) {\n        try {\n            await waitImmediate(); // Acts like setImmediate but preserves the stack-trace.\n            listener(data);\n        }\n        catch (error) {\n            // Stop error propagation.\n            throwUnhandledRejection(error);\n        }\n    }\n    _runEffects() {\n        for (const handle of Array.from(this._effects)) {\n            const cleanup = handle.effect();\n            if (typeof cleanup === 'function') {\n                handle.cleanup = cleanup;\n            }\n        }\n    }\n    _cleanupEffects() {\n        var _a;\n        for (const handle of Array.from(this._effects)) {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n            handle.cleanup = undefined;\n        }\n    }\n}\nfunction throwUnhandledRejection(error) {\n    setTimeout(() => {\n        throw error;\n    });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise((resolve) => setTimeout(resolve));\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}