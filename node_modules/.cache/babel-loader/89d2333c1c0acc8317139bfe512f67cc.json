{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n  var contract = call.contract,\n    method = call.method,\n    args = call.args;\n  console.warn(\"Invalid contract call: address=\".concat(contract.address, \" method=\").concat(method, \" args=\").concat(args));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n  var contract = call.contract,\n    method = call.method,\n    args = call.args;\n  if (!contract.address || !method) {\n    throw new Error('Missing contract address or method name');\n  }\n  try {\n    contract.interface.encodeFunctionData(method, args);\n    return call;\n  } catch (err) {\n    throw new Error(\"Invalid contract call for method=\\\"\".concat(method, \"\\\" on contract=\\\"\").concat(contract.address, \"\\\": \").concat(err.message));\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId) {\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  if (!call) {\n    return undefined;\n  }\n  try {\n    validateCall(call);\n  } catch (e) {\n    return e;\n  }\n  var contract = call.contract,\n    method = call.method,\n    args = call.args;\n  var isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n  var refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n  return {\n    address: contract.address,\n    data: contract.interface.encodeFunctionData(method, args),\n    chainId: chainId,\n    isStatic: isStatic,\n    refreshPerBlocks: refreshPerBlocks\n  };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n  var unique = [];\n  var used = {};\n  var _iterator = _createForOfIteratorHelper(requests),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var request = _step.value;\n      if (!used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)]) {\n        unique.push(request);\n        used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n  var callsForUpdate = [];\n  var _iterator2 = _createForOfIteratorHelper(requests),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var request = _step2.value;\n      if (options) {\n        if (options.chainId && options.chainId !== request.chainId) {\n          continue;\n        }\n        if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n          continue;\n        }\n        var currentBlock = options.blockNumber;\n        if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n          if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n            continue;\n          }\n        }\n      }\n      callsForUpdate.push(request);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n  var _a;\n  if (!result || !call) {\n    return undefined;\n  }\n  var value = result.value,\n    success = result.success;\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      var errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n  if (data === '0x') {\n    return 'Call reverted without a cause message';\n  }\n  if (data.startsWith('0x08c379a0')) {\n    // decode Error(string)\n    var reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n    if (reason.startsWith('VM Exception')) {\n      return defaultMulticall1ErrorMessage;\n    }\n    return reason;\n  }\n  if (data.startsWith('0x4e487b71')) {\n    // decode Panic(uint)\n    var code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n    return \"panic code \".concat(code._hex);\n  }\n  try {\n    var errorInfo = contractInterface.parseError(data);\n    return \"error \".concat(errorInfo.name);\n  } catch (e) {\n    console.error(e);\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        throw new Error('Missing contract address or method name');\n    }\n    try {\n        contract.interface.encodeFunctionData(method, args);\n        return call;\n    }\n    catch (err) {\n        throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`);\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n    var _a;\n    if (!call) {\n        return undefined;\n    }\n    try {\n        validateCall(call);\n    }\n    catch (e) {\n        return e;\n    }\n    const { contract, method, args } = call;\n    const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n        address: contract.address,\n        data: contract.interface.encodeFunctionData(method, args),\n        chainId,\n        isStatic,\n        refreshPerBlocks,\n    };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n    const callsForUpdate = [];\n    for (const request of requests) {\n        if (options) {\n            if (options.chainId && options.chainId !== request.chainId) {\n                continue;\n            }\n            if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n                continue;\n            }\n            const currentBlock = options.blockNumber;\n            if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n                if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n                    continue;\n                }\n            }\n        }\n        callsForUpdate.push(request);\n    }\n    return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    var _a;\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n    if (data === '0x') {\n        return 'Call reverted without a cause message';\n    }\n    if (data.startsWith('0x08c379a0')) {\n        // decode Error(string)\n        const reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n        if (reason.startsWith('VM Exception')) {\n            return defaultMulticall1ErrorMessage;\n        }\n        return reason;\n    }\n    if (data.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n        return `panic code ${code._hex}`;\n    }\n    try {\n        const errorInfo = contractInterface.parseError(data);\n        return `error ${errorInfo.name}`;\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}