{"ast":null,"code":"import { decodeUint, wordLength, fail } from '../common';\nexport function decodeTryAggregate(calldata) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  var errorMethodId = '0x08c379a0';\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed');\n  }\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n  var getNumber = function getNumber(offset) {\n    return decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n  };\n  // The array offset must be 0x20 - nothing is before the array\n  if (getNumber(0) !== 0x20) {\n    fail();\n  }\n  var arraySize = getNumber(1);\n  var calls = [];\n  for (var i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    var callOffset = 2 * getNumber(i + 2) + 2 * wordLength;\n    // position of the call if we split calldata in chunks of 32 bytes\n    var pos = callOffset / wordLength;\n    // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n    var successEncoded = getNumber(pos);\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail();\n    }\n    var success = successEncoded === 1;\n    if (getNumber(pos + 1) !== 0x40) {\n      fail();\n    }\n    var returnDataOffset = (pos + 3) * wordLength;\n    var returnDataLength = getNumber(pos + 2);\n    var returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength);\n    var call = [success, '0x' + returnData];\n    calls.push(call);\n  }\n  return [calls];\n}","map":{"version":3,"sources":["../../../../../src/abi/multicall2/decoder.ts"],"names":[],"mappings":"AAAA,SAAS,UAAU,EAAE,UAAU,EAAE,IAAI,QAAQ,WAAW;AAExD,OAAM,SAAU,kBAAkB,CAAC,QAAgB,EAAA;EACjD;EACA,IAAM,aAAa,GAAG,YAAY;EAClC,IAAI,QAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE;IACtC,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC;EACrD;EACD,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA,CAAC;EAC7B,IAAM,SAAS,GAAG,SAAZ,SAAS,CAAI,MAAc;IAAA,OAAK,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,GAAG,UAAU,EAAE,CAAC,MAAM,GAAG,CAAC,IAAI,UAAU,CAAC,CAAC;EAAA;EAEhH;EACA,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACzB,IAAI,EAAE;EACP;EACD,IAAM,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;EAC9B,IAAM,KAAK,GAAwB,EAAE;EAErC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;IAClC;IACA,IAAM,UAAU,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,UAAU;IACxD;IACA,IAAM,GAAG,GAAG,UAAU,GAAG,UAAU;IACnC;IACA;IACA,IAAM,cAAc,GAAG,SAAS,CAAC,GAAG,CAAC;IACrC,IAAI,cAAc,KAAK,CAAC,IAAI,cAAc,KAAK,CAAC,EAAE;MAChD,IAAI,EAAE;IACP;IACD,IAAM,OAAO,GAAG,cAAc,KAAK,CAAC;IACpC,IAAI,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;MAC/B,IAAI,EAAE;IACP;IACD,IAAM,gBAAgB,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,UAAU;IAC/C,IAAM,gBAAgB,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;IAC3C,IAAM,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,gBAAgB,GAAG,CAAC,GAAG,gBAAgB,CAAC;IAC5F,IAAM,IAAI,GAAsB,CAAC,OAAO,EAAE,IAAI,GAAG,UAAU,CAAC;IAC5D,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;EACjB;EACD,OAAO,CAAC,KAAK,CAAC;AAChB","sourceRoot":"","sourcesContent":["import { decodeUint, wordLength, fail } from '../common';\nexport function decodeTryAggregate(calldata) {\n    // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n    const errorMethodId = '0x08c379a0';\n    if (calldata.startsWith(errorMethodId)) {\n        throw new Error('Multicall2 aggregate: call failed');\n    }\n    calldata = calldata.slice(2); // 'remove 0x prefix'\n    const getNumber = (offset) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n    // The array offset must be 0x20 - nothing is before the array\n    if (getNumber(0) !== 0x20) {\n        fail();\n    }\n    const arraySize = getNumber(1);\n    const calls = [];\n    for (let i = 0; i < arraySize; i++) {\n        // offset of the call number i\n        const callOffset = 2 * getNumber(i + 2) + 2 * wordLength;\n        // position of the call if we split calldata in chunks of 32 bytes\n        const pos = callOffset / wordLength;\n        // returnData is encoded as a flag showing if the call was successful,\n        // data offset, which should be equal to 0x40, data length and the data itself\n        const successEncoded = getNumber(pos);\n        if (successEncoded !== 1 && successEncoded !== 0) {\n            fail();\n        }\n        const success = successEncoded === 1;\n        if (getNumber(pos + 1) !== 0x40) {\n            fail();\n        }\n        const returnDataOffset = (pos + 3) * wordLength;\n        const returnDataLength = getNumber(pos + 2);\n        const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength);\n        const call = [success, '0x' + returnData];\n        calls.push(call);\n    }\n    return [calls];\n}\n//# sourceMappingURL=decoder.js.map"]},"metadata":{},"sourceType":"module"}