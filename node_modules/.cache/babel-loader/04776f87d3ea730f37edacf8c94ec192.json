{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { ChaCha20Poly1305 as J } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Ye } from \"@stablelib/hkdf\";\nimport { randomBytes as Q } from \"@stablelib/random\";\nimport { SHA256 as We, hash as Z } from \"@stablelib/sha256\";\nimport * as X from \"@stablelib/x25519\";\nimport { toString as l, fromString as f, concat as ee } from \"uint8arrays\";\nimport { detect as Je } from \"detect-browser\";\nimport { toMiliseconds as D, FIVE_MINUTES as ne, fromMiliseconds as Qe } from \"@walletconnect/time\";\nimport { getDocument as Ze, getNavigator as te, getLocation as re } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Xe } from \"@walletconnect/window-metadata\";\nimport * as P from \"query-string\";\nimport { RELAY_JSONRPC as en } from \"@walletconnect/relay-api\";\nvar T = \":\";\nfunction oe(e) {\n  var _e$split = e.split(T),\n    _e$split2 = _slicedToArray(_e$split, 2),\n    n = _e$split2[0],\n    t = _e$split2[1];\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction se(e) {\n  var n = e.namespace,\n    t = e.reference;\n  return [n, t].join(T);\n}\nfunction j(e) {\n  var _e$split3 = e.split(T),\n    _e$split4 = _slicedToArray(_e$split3, 3),\n    n = _e$split4[0],\n    t = _e$split4[1],\n    r = _e$split4[2];\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction ie(e) {\n  var n = e.namespace,\n    t = e.reference,\n    r = e.address;\n  return [n, t, r].join(T);\n}\nfunction V(e, n) {\n  var t = [];\n  return e.forEach(function (r) {\n    var o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction ce(e) {\n  var _j = j(e),\n    n = _j.address;\n  return n;\n}\nfunction ae(e) {\n  var _j2 = j(e),\n    n = _j2.namespace,\n    t = _j2.reference;\n  return se({\n    namespace: n,\n    reference: t\n  });\n}\nfunction nn(e, n) {\n  var _oe = oe(n),\n    t = _oe.namespace,\n    r = _oe.reference;\n  return ie({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction tn(e) {\n  return V(e, ce);\n}\nfunction ue(e) {\n  return V(e, ae);\n}\nfunction rn(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(o.accounts));\n  }), t;\n}\nfunction on(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(ue(o.accounts)));\n  }), t;\n}\nfunction sn(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(R(r, o)));\n  }), t;\n}\nfunction R(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nvar U = function U(e) {\n    return e === null || e === void 0 ? void 0 : e.split(\":\");\n  },\n  de = function de(e) {\n    var n = e && U(e);\n    if (n) return n[3];\n  },\n  cn = function cn(e) {\n    var n = e && U(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  le = function le(e) {\n    var n = e && U(e);\n    if (n) return n.pop();\n  },\n  an = function an(e, n) {\n    var t = \"\".concat(e.domain, \" wants you to sign in with your Ethereum account:\"),\n      r = le(n),\n      o = e.statement,\n      s = \"URI: \".concat(e.aud),\n      i = \"Version: \".concat(e.version),\n      a = \"Chain ID: \".concat(de(n)),\n      p = \"Nonce: \".concat(e.nonce),\n      y = \"Issued At: \".concat(e.iat),\n      m = e.resources && e.resources.length > 0 ? \"Resources:\\n\".concat(e.resources.map(function (c) {\n        return \"- \".concat(c);\n      }).join(\"\\n\")) : void 0;\n    return [t, r, \"\", o, \"\", s, i, a, p, y, m].filter(function (c) {\n      return c != null;\n    }).join(\"\\n\");\n  },\n  M = \"base10\",\n  u = \"base16\",\n  A = \"base64pad\",\n  _ = \"utf8\",\n  K = 0,\n  b = 1,\n  un = 0,\n  fe = 1,\n  k = 12,\n  L = 32;\nfunction dn() {\n  var e = X.generateKeyPair();\n  return {\n    privateKey: l(e.secretKey, u),\n    publicKey: l(e.publicKey, u)\n  };\n}\nfunction ln() {\n  var e = Q(L);\n  return l(e, u);\n}\nfunction fn(e, n) {\n  var t = X.sharedKey(f(e, u), f(n, u)),\n    r = new Ye(We, t).expand(L);\n  return l(r, u);\n}\nfunction pn(e) {\n  var n = Z(f(e, u));\n  return l(n, u);\n}\nfunction mn(e) {\n  var n = Z(f(e, _));\n  return l(n, u);\n}\nfunction pe(e) {\n  return f(\"\".concat(e), M);\n}\nfunction S(e) {\n  return Number(l(e, M));\n}\nfunction yn(e) {\n  var n = pe(typeof e.type < \"u\" ? e.type : K);\n  if (S(n) === b && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  var t = typeof e.senderPublicKey < \"u\" ? f(e.senderPublicKey, u) : void 0,\n    r = typeof e.iv < \"u\" ? f(e.iv, u) : Q(k),\n    o = new J(f(e.symKey, u)).seal(r, f(e.message, _));\n  return me({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction En(e) {\n  var n = new J(f(e.symKey, u)),\n    _F = F(e.encoded),\n    t = _F.sealed,\n    r = _F.iv,\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return l(o, _);\n}\nfunction me(e) {\n  if (S(e.type) === b) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return l(ee([e.type, e.senderPublicKey, e.iv, e.sealed]), A);\n  }\n  return l(ee([e.type, e.iv, e.sealed]), A);\n}\nfunction F(e) {\n  var n = f(e, A),\n    t = n.slice(un, fe),\n    r = fe;\n  if (S(t) === b) {\n    var a = r + L,\n      p = a + k,\n      y = n.slice(r, a),\n      m = n.slice(a, p),\n      c = n.slice(p);\n    return {\n      type: t,\n      sealed: c,\n      iv: m,\n      senderPublicKey: y\n    };\n  }\n  var o = r + k,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction gn(e, n) {\n  var t = F(e);\n  return ye({\n    type: S(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? l(t.senderPublicKey, u) : void 0,\n    receiverPublicKey: n === null || n === void 0 ? void 0 : n.receiverPublicKey\n  });\n}\nfunction ye(e) {\n  var n = (e === null || e === void 0 ? void 0 : e.type) || K;\n  if (n === b) {\n    if (typeof (e === null || e === void 0 ? void 0 : e.senderPublicKey) > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof (e === null || e === void 0 ? void 0 : e.receiverPublicKey) > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e === null || e === void 0 ? void 0 : e.senderPublicKey,\n    receiverPublicKey: e === null || e === void 0 ? void 0 : e.receiverPublicKey\n  };\n}\nfunction hn(e) {\n  return e.type === b && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar Nn = Object.defineProperty,\n  Ee = Object.getOwnPropertySymbols,\n  vn = Object.prototype.hasOwnProperty,\n  bn = Object.prototype.propertyIsEnumerable,\n  ge = function ge(e, n, t) {\n    return n in e ? Nn(e, n, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: t\n    }) : e[n] = t;\n  },\n  he = function he(e, n) {\n    for (var t in n || (n = {})) vn.call(n, t) && ge(e, t, n[t]);\n    if (Ee) {\n      var _iterator = _createForOfIteratorHelper(Ee(n)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var t = _step.value;\n          bn.call(n, t) && ge(e, t, n[t]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return e;\n  };\nvar Ne = \"ReactNative\",\n  O = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  C = \" \",\n  On = \":\",\n  ve = \"/\",\n  x = 2,\n  Sn = 1e3,\n  be = \"js\";\nfunction H() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction Oe() {\n  return !Ze() && !!te() && navigator.product === Ne;\n}\nfunction Se() {\n  return !H() && !!te();\n}\nfunction q() {\n  return Oe() ? O.reactNative : H() ? O.node : Se() ? O.browser : O.unknown;\n}\nfunction Ie(e, n) {\n  var t = P.parse(e);\n  return t = he(he({}, t), n), e = P.stringify(t), e;\n}\nfunction In() {\n  return Xe() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Pn(e, n) {\n  var t;\n  var r = q(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = re()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Pe() {\n  var e = Je();\n  if (e === null) return \"unknown\";\n  var n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Te() {\n  var e;\n  var n = q();\n  return n === O.browser ? [n, ((e = re()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Re(e, n, t) {\n  var r = Pe(),\n    o = Te();\n  return [[e, n].join(\"-\"), [be, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Tn(_ref) {\n  var e = _ref.protocol,\n    n = _ref.version,\n    t = _ref.relayUrl,\n    r = _ref.sdkVersion,\n    o = _ref.auth,\n    s = _ref.projectId,\n    i = _ref.useOnCloseEvent;\n  var a = t.split(\"?\"),\n    p = Re(e, n, r),\n    y = {\n      auth: o,\n      ua: p,\n      projectId: s,\n      useOnCloseEvent: i || void 0\n    },\n    m = Ie(a[1] || \"\", y);\n  return a[0] + \"?\" + m;\n}\nfunction Rn(e) {\n  var n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  var t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Un(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(\"Missing or invalid \\\"\".concat(n, \"\\\" param\"));\n}\nfunction Ue(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return Ae(e.split(ve), n);\n}\nfunction An(e) {\n  return Ue(e).join(C);\n}\nfunction g(e, n) {\n  return e.filter(function (t) {\n    return n.includes(t);\n  }).length === e.length;\n}\nfunction Ae(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction _n(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Cn(e) {\n  return new Map(Object.entries(e));\n}\nfunction wn(e, n) {\n  var t = {};\n  return Object.keys(e).forEach(function (r) {\n    t[r] = n(e[r]);\n  }), t;\n}\nvar $n = function $n(e) {\n  return e;\n};\nfunction _e(e) {\n  return e.trim().replace(/^\\w/, function (n) {\n    return n.toUpperCase();\n  });\n}\nfunction Dn(e) {\n  return e.split(C).map(function (n) {\n    return _e(n);\n  }).join(C);\n}\nfunction jn() {\n  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ne;\n  var n = arguments.length > 1 ? arguments[1] : undefined;\n  var t = D(e || ne);\n  var r, o, s;\n  return {\n    resolve: function resolve(i) {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: function reject(i) {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: function done() {\n      return new Promise(function (i, a) {\n        s = setTimeout(function () {\n          a(new Error(n));\n        }, t), r = i, o = a;\n      });\n    }\n  };\n}\nfunction Vn(e, n, t) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(r, o) {\n      var s, i;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            s = setTimeout(function () {\n              return o(new Error(t));\n            }, n);\n            _context.prev = 1;\n            _context.next = 4;\n            return e;\n          case 4:\n            i = _context.sent;\n            r(i);\n            _context.next = 11;\n            break;\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](1);\n            o(_context.t0);\n          case 11:\n            clearTimeout(s);\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 8]]);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n}\nfunction B(e, n) {\n  if (typeof n == \"string\" && n.startsWith(\"\".concat(e, \":\"))) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return \"topic:\".concat(n);\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return \"id:\".concat(n);\n  }\n  throw new Error(\"Unknown expirer target type: \".concat(e));\n}\nfunction Mn(e) {\n  return B(\"topic\", e);\n}\nfunction Kn(e) {\n  return B(\"id\", e);\n}\nfunction kn(e) {\n  var _e$split5 = e.split(\":\"),\n    _e$split6 = _slicedToArray(_e$split5, 2),\n    n = _e$split6[0],\n    t = _e$split6[1],\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(\"Invalid target, expected id:number or topic:string, got \".concat(n, \":\").concat(t));\n  return r;\n}\nfunction Ln(e, n) {\n  return Qe((n || Date.now()) + D(e));\n}\nfunction Fn(e) {\n  return Date.now() >= D(e);\n}\nfunction xn(e, n) {\n  return \"\".concat(e).concat(n ? \":\".concat(n) : \"\");\n}\nvar Ce = \"irn\";\nfunction Hn(e) {\n  return (e === null || e === void 0 ? void 0 : e.relay) || {\n    protocol: Ce\n  };\n}\nfunction qn(e) {\n  var n = en[e];\n  if (typeof n > \"u\") throw new Error(\"Relay Protocol not supported: \".concat(e));\n  return n;\n}\nvar Bn = Object.defineProperty,\n  we = Object.getOwnPropertySymbols,\n  Gn = Object.prototype.hasOwnProperty,\n  zn = Object.prototype.propertyIsEnumerable,\n  $e = function $e(e, n, t) {\n    return n in e ? Bn(e, n, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: t\n    }) : e[n] = t;\n  },\n  Yn = function Yn(e, n) {\n    for (var t in n || (n = {})) Gn.call(n, t) && $e(e, t, n[t]);\n    if (we) {\n      var _iterator2 = _createForOfIteratorHelper(we(n)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var t = _step2.value;\n          zn.call(n, t) && $e(e, t, n[t]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    return e;\n  };\nfunction De(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  var t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(function (o) {\n    if (o.startsWith(r)) {\n      var s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction Wn(e) {\n  var n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = P.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: De(i)\n  };\n}\nfunction je(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  var t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(function (o) {\n    var s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction Jn(e) {\n  return \"\".concat(e.protocol, \":\").concat(e.topic, \"@\").concat(e.version, \"?\") + P.stringify(Yn({\n    symKey: e.symKey\n  }, je(e.relay)));\n}\nfunction N(e) {\n  var n = [];\n  return e.forEach(function (t) {\n    var _t$split = t.split(\":\"),\n      _t$split2 = _slicedToArray(_t$split, 2),\n      r = _t$split2[0],\n      o = _t$split2[1];\n    n.push(\"\".concat(r, \":\").concat(o));\n  }), n;\n}\nfunction Ve(e) {\n  var n = [];\n  return Object.values(e).forEach(function (t) {\n    n.push.apply(n, _toConsumableArray(N(t.accounts)));\n  }), n;\n}\nfunction Me(e, n) {\n  var t = [];\n  return Object.values(e).forEach(function (r) {\n    N(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.methods));\n  }), t;\n}\nfunction Ke(e, n) {\n  var t = [];\n  return Object.values(e).forEach(function (r) {\n    N(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.events));\n  }), t;\n}\nfunction Qn(e, n) {\n  var t = Be(e, n);\n  if (t) throw new Error(t.message);\n  var r = {};\n  for (var _i = 0, _Object$entries = Object.entries(e); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      o = _Object$entries$_i[0],\n      s = _Object$entries$_i[1];\n    r[o] = {\n      methods: s.methods,\n      events: s.events,\n      chains: s.accounts.map(function (i) {\n        return \"\".concat(i.split(\":\")[0], \":\").concat(i.split(\":\")[1]);\n      })\n    };\n  }\n  return r;\n}\nvar Zn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Xn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction E(e, n) {\n  var _Xn$e = Xn[e],\n    t = _Xn$e.message,\n    r = _Xn$e.code;\n  return {\n    message: n ? \"\".concat(t, \" \").concat(n) : t,\n    code: r\n  };\n}\nfunction v(e, n) {\n  var _Zn$e = Zn[e],\n    t = _Zn$e.message,\n    r = _Zn$e.code;\n  return {\n    message: n ? \"\".concat(t, \" \").concat(n) : t,\n    code: r\n  };\n}\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction G(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction h(e) {\n  return typeof e > \"u\";\n}\nfunction d(e, n) {\n  return n && h(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction w(e, n) {\n  return n && h(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction et(e, n) {\n  var t = n.requiredNamespaces,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  var s = !0;\n  return g(o, r) ? (r.forEach(function (i) {\n    var _e$namespaces$i = e.namespaces[i],\n      a = _e$namespaces$i.accounts,\n      p = _e$namespaces$i.methods,\n      y = _e$namespaces$i.events,\n      m = N(a),\n      c = t[i];\n    (!g(R(i, c), m) || !g(c.methods, p) || !g(c.events, y)) && (s = !1);\n  }), s) : !1;\n}\nfunction $(e) {\n  return d(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction ke(e) {\n  if (d(e, !1) && e.includes(\":\")) {\n    var n = e.split(\":\");\n    if (n.length === 3) {\n      var t = n[0] + \":\" + n[1];\n      return !!n[2] && $(t);\n    }\n  }\n  return !1;\n}\nfunction nt(e) {\n  if (d(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch (_unused) {\n    return !1;\n  }\n  return !1;\n}\nfunction tt(e) {\n  var n;\n  return (n = e === null || e === void 0 ? void 0 : e.proposer) == null ? void 0 : n.publicKey;\n}\nfunction rt(e) {\n  return e === null || e === void 0 ? void 0 : e.topic;\n}\nfunction ot(e, n) {\n  var t = null;\n  return d(e === null || e === void 0 ? void 0 : e.publicKey, !1) || (t = E(\"MISSING_OR_INVALID\", \"\".concat(n, \" controller public key should be a string\"))), t;\n}\nfunction z(e) {\n  var n = !0;\n  return I(e) ? e.length && (n = e.every(function (t) {\n    return d(t, !1);\n  })) : n = !1, n;\n}\nfunction Le(e, n, t) {\n  var r = null;\n  return I(n) ? n.forEach(function (o) {\n    r || (!$(o) || !o.includes(e)) && (r = v(\"UNSUPPORTED_CHAINS\", \"\".concat(t, \", chain \").concat(o, \" should be a string and conform to \\\"namespace:chainId\\\" format\")));\n  }) : r = v(\"UNSUPPORTED_CHAINS\", \"\".concat(t, \", chains \").concat(n, \" should be an array of strings conforming to \\\"namespace:chainId\\\" format\")), r;\n}\nfunction Fe(e, n) {\n  var t = null;\n  return Object.entries(e).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      r = _ref4[0],\n      o = _ref4[1];\n    if (t) return;\n    var s = Le(r, R(r, o), \"\".concat(n, \" requiredNamespace\"));\n    s && (t = s);\n  }), t;\n}\nfunction xe(e, n) {\n  var t = null;\n  return I(e) ? e.forEach(function (r) {\n    t || ke(r) || (t = v(\"UNSUPPORTED_ACCOUNTS\", \"\".concat(n, \", account \").concat(r, \" should be a string and conform to \\\"namespace:chainId:address\\\" format\")));\n  }) : t = v(\"UNSUPPORTED_ACCOUNTS\", \"\".concat(n, \", accounts should be an array of strings conforming to \\\"namespace:chainId:address\\\" format\")), t;\n}\nfunction He(e, n) {\n  var t = null;\n  return Object.values(e).forEach(function (r) {\n    if (t) return;\n    var o = xe(r === null || r === void 0 ? void 0 : r.accounts, \"\".concat(n, \" namespace\"));\n    o && (t = o);\n  }), t;\n}\nfunction qe(e, n) {\n  var t = null;\n  return z(e === null || e === void 0 ? void 0 : e.methods) ? z(e === null || e === void 0 ? void 0 : e.events) || (t = v(\"UNSUPPORTED_EVENTS\", \"\".concat(n, \", events should be an array of strings or empty array for no events\"))) : t = v(\"UNSUPPORTED_METHODS\", \"\".concat(n, \", methods should be an array of strings or empty array for no methods\")), t;\n}\nfunction Y(e, n) {\n  var t = null;\n  return Object.values(e).forEach(function (r) {\n    if (t) return;\n    var o = qe(r, \"\".concat(n, \", namespace\"));\n    o && (t = o);\n  }), t;\n}\nfunction st(e, n, t) {\n  var r = null;\n  if (e && G(e)) {\n    var o = Y(e, n);\n    o && (r = o);\n    var s = Fe(e, n);\n    s && (r = s);\n  } else r = E(\"MISSING_OR_INVALID\", \"\".concat(n, \", \").concat(t, \" should be an object with data\"));\n  return r;\n}\nfunction Be(e, n) {\n  var t = null;\n  if (e && G(e)) {\n    var r = Y(e, n);\n    r && (t = r);\n    var o = He(e, n);\n    o && (t = o);\n  } else t = E(\"MISSING_OR_INVALID\", \"\".concat(n, \", namespaces should be an object with data\"));\n  return t;\n}\nfunction Ge(e) {\n  return d(e.protocol, !0);\n}\nfunction it(e, n) {\n  var t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(function (r) {\n    t = Ge(r);\n  }), t;\n}\nfunction ct(e) {\n  return typeof e == \"number\";\n}\nfunction at(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction ut(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !w(e.code, !1) || !e.message || !d(e.message, !1));\n}\nfunction dt(e) {\n  return !(h(e) || !d(e.method, !1));\n}\nfunction lt(e) {\n  return !(h(e) || h(e.result) && h(e.error) || !w(e.id, !1) || !d(e.jsonrpc, !1));\n}\nfunction ft(e) {\n  return !(h(e) || !d(e.name, !1));\n}\nfunction pt(e, n) {\n  return !(!$(n) || !Ve(e).includes(n));\n}\nfunction mt(e, n, t) {\n  return d(t, !1) ? Me(e, n).includes(t) : !1;\n}\nfunction yt(e, n, t) {\n  return d(t, !1) ? Ke(e, n).includes(t) : !1;\n}\nfunction Et(e, n, t) {\n  var r = null;\n  var o = gt(e),\n    s = ht(n),\n    i = Object.keys(o),\n    a = Object.keys(s),\n    p = ze(Object.keys(e)),\n    y = ze(Object.keys(n)),\n    m = p.filter(function (c) {\n      return !y.includes(c);\n    });\n  return m.length && (r = E(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces keys don't satisfy requiredNamespaces.\\n      Required: \").concat(m.toString(), \"\\n      Received: \").concat(Object.keys(n).toString()))), g(i, a) || (r = E(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces chains don't satisfy required namespaces.\\n      Required: \").concat(i.toString(), \"\\n      Approved: \").concat(a.toString()))), Object.keys(n).forEach(function (c) {\n    if (!c.includes(\":\") || r) return;\n    var W = N(n[c].accounts);\n    W.includes(c) || (r = E(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces accounts don't satisfy namespace accounts for \").concat(c, \"\\n        Required: \").concat(c, \"\\n        Approved: \").concat(W.toString())));\n  }), i.forEach(function (c) {\n    r || (g(o[c].methods, s[c].methods) ? g(o[c].events, s[c].events) || (r = E(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces events don't satisfy namespace events for \").concat(c))) : r = E(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces methods don't satisfy namespace methods for \").concat(c)));\n  }), r;\n}\nfunction gt(e) {\n  var n = {};\n  return Object.keys(e).forEach(function (t) {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(function (o) {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction ze(e) {\n  return _toConsumableArray(new Set(e.map(function (n) {\n    return n.includes(\":\") ? n.split(\":\")[0] : n;\n  })));\n}\nfunction ht(e) {\n  var n = {};\n  return Object.keys(e).forEach(function (t) {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      var r = N(e[t].accounts);\n      r === null || r === void 0 ? void 0 : r.forEach(function (o) {\n        n[o] = {\n          accounts: e[t].accounts.filter(function (s) {\n            return s.includes(\"\".concat(o, \":\"));\n          }),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction Nt(e, n) {\n  return w(e, !1) && e <= n.max && e >= n.min;\n}\nexport { M as BASE10, u as BASE16, A as BASE64, On as COLON, x as DEFAULT_DEPTH, C as EMPTY_SPACE, O as ENV_MAP, Sn as ONE_THOUSAND, Ne as REACT_NATIVE_PRODUCT, Ce as RELAYER_DEFAULT_PROTOCOL, be as SDK_TYPE, ve as SLASH, K as TYPE_0, b as TYPE_1, _ as UTF8, Ie as appendToQueryString, Un as assertType, Ln as calcExpiry, Dn as capitalize, _e as capitalizeWord, jn as createDelayedPromise, Vn as createExpiringPromise, S as decodeTypeByte, En as decrypt, fn as deriveSymKey, F as deserialize, pe as encodeTypeByte, yn as encrypt, xn as engineEvent, $n as enumify, ie as formatAccountId, nn as formatAccountWithChain, se as formatChainId, B as formatExpirerTarget, Kn as formatIdTarget, an as formatMessage, An as formatMessageContext, je as formatRelayParams, Tn as formatRelayRpcUrl, Mn as formatTopicTarget, Re as formatUA, Jn as formatUri, dn as generateKeyPair, ln as generateRandomBytes32, N as getAccountsChains, rn as getAccountsFromNamespaces, ce as getAddressFromAccount, tn as getAddressesFromAccounts, In as getAppMetadata, ae as getChainFromAccount, ue as getChainsFromAccounts, R as getChainsFromNamespace, on as getChainsFromNamespaces, sn as getChainsFromRequiredNamespaces, le as getDidAddress, U as getDidAddressSegments, de as getDidChainId, q as getEnvironment, Rn as getHttpUrl, E as getInternalError, Te as getJavascriptID, Pe as getJavascriptOS, Ae as getLastItems, cn as getNamespacedDidChainId, Ve as getNamespacesChains, Ke as getNamespacesEventsForChainId, Me as getNamespacesMethodsForChainId, Pn as getRelayClientMetadata, qn as getRelayProtocolApi, Hn as getRelayProtocolName, Qn as getRequiredNamespacesFromNamespaces, v as getSdkError, V as getUniqueValues, g as hasOverlap, pn as hashKey, mn as hashMessage, Se as isBrowser, Et as isConformingNamespaces, Fn as isExpired, H as isNode, tt as isProposalStruct, Oe as isReactNative, et as isSessionCompatible, rt as isSessionStruct, hn as isTypeOneEnvelope, h as isUndefined, ke as isValidAccountId, xe as isValidAccounts, qe as isValidActions, I as isValidArray, $ as isValidChainId, Le as isValidChains, ot as isValidController, ut as isValidErrorReason, ft as isValidEvent, ct as isValidId, He as isValidNamespaceAccounts, Y as isValidNamespaceActions, Fe as isValidNamespaceChains, z as isValidNamespaceMethodsOrEvents, Be as isValidNamespaces, pt as isValidNamespacesChainId, yt as isValidNamespacesEvent, mt as isValidNamespacesRequest, w as isValidNumber, G as isValidObject, at as isValidParams, Ge as isValidRelay, it as isValidRelays, dt as isValidRequest, Nt as isValidRequestExpiry, st as isValidRequiredNamespaces, lt as isValidResponse, d as isValidString, nt as isValidUrl, wn as mapEntries, _n as mapToObj, Cn as objToMap, j as parseAccountId, oe as parseChainId, Ue as parseContextNames, kn as parseExpirerTarget, De as parseRelayParams, Wn as parseUri, me as serialize, gn as validateDecoding, ye as validateEncoding };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import{ChaCha20Poly1305 as J}from\"@stablelib/chacha20poly1305\";import{HKDF as Ye}from\"@stablelib/hkdf\";import{randomBytes as Q}from\"@stablelib/random\";import{SHA256 as We,hash as Z}from\"@stablelib/sha256\";import*as X from\"@stablelib/x25519\";import{toString as l,fromString as f,concat as ee}from\"uint8arrays\";import{detect as Je}from\"detect-browser\";import{toMiliseconds as D,FIVE_MINUTES as ne,fromMiliseconds as Qe}from\"@walletconnect/time\";import{getDocument as Ze,getNavigator as te,getLocation as re}from\"@walletconnect/window-getters\";import{getWindowMetadata as Xe}from\"@walletconnect/window-metadata\";import*as P from\"query-string\";import{RELAY_JSONRPC as en}from\"@walletconnect/relay-api\";const T=\":\";function oe(e){const[n,t]=e.split(T);return{namespace:n,reference:t}}function se(e){const{namespace:n,reference:t}=e;return[n,t].join(T)}function j(e){const[n,t,r]=e.split(T);return{namespace:n,reference:t,address:r}}function ie(e){const{namespace:n,reference:t,address:r}=e;return[n,t,r].join(T)}function V(e,n){const t=[];return e.forEach(r=>{const o=n(r);t.includes(o)||t.push(o)}),t}function ce(e){const{address:n}=j(e);return n}function ae(e){const{namespace:n,reference:t}=j(e);return se({namespace:n,reference:t})}function nn(e,n){const{namespace:t,reference:r}=oe(n);return ie({namespace:t,reference:r,address:e})}function tn(e){return V(e,ce)}function ue(e){return V(e,ae)}function rn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...o.accounts)}),t}function on(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...ue(o.accounts))}),t}function sn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...R(r,o))}),t}function R(e,n){return e.includes(\":\")?[e]:n.chains||[]}const U=e=>e?.split(\":\"),de=e=>{const n=e&&U(e);if(n)return n[3]},cn=e=>{const n=e&&U(e);if(n)return n[2]+\":\"+n[3]},le=e=>{const n=e&&U(e);if(n)return n.pop()},an=(e,n)=>{const t=`${e.domain} wants you to sign in with your Ethereum account:`,r=le(n),o=e.statement,s=`URI: ${e.aud}`,i=`Version: ${e.version}`,a=`Chain ID: ${de(n)}`,p=`Nonce: ${e.nonce}`,y=`Issued At: ${e.iat}`,m=e.resources&&e.resources.length>0?`Resources:\n${e.resources.map(c=>`- ${c}`).join(`\n`)}`:void 0;return[t,r,\"\",o,\"\",s,i,a,p,y,m].filter(c=>c!=null).join(`\n`)},M=\"base10\",u=\"base16\",A=\"base64pad\",_=\"utf8\",K=0,b=1,un=0,fe=1,k=12,L=32;function dn(){const e=X.generateKeyPair();return{privateKey:l(e.secretKey,u),publicKey:l(e.publicKey,u)}}function ln(){const e=Q(L);return l(e,u)}function fn(e,n){const t=X.sharedKey(f(e,u),f(n,u)),r=new Ye(We,t).expand(L);return l(r,u)}function pn(e){const n=Z(f(e,u));return l(n,u)}function mn(e){const n=Z(f(e,_));return l(n,u)}function pe(e){return f(`${e}`,M)}function S(e){return Number(l(e,M))}function yn(e){const n=pe(typeof e.type<\"u\"?e.type:K);if(S(n)===b&&typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");const t=typeof e.senderPublicKey<\"u\"?f(e.senderPublicKey,u):void 0,r=typeof e.iv<\"u\"?f(e.iv,u):Q(k),o=new J(f(e.symKey,u)).seal(r,f(e.message,_));return me({type:n,sealed:o,iv:r,senderPublicKey:t})}function En(e){const n=new J(f(e.symKey,u)),{sealed:t,iv:r}=F(e.encoded),o=n.open(r,t);if(o===null)throw new Error(\"Failed to decrypt\");return l(o,_)}function me(e){if(S(e.type)===b){if(typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");return l(ee([e.type,e.senderPublicKey,e.iv,e.sealed]),A)}return l(ee([e.type,e.iv,e.sealed]),A)}function F(e){const n=f(e,A),t=n.slice(un,fe),r=fe;if(S(t)===b){const a=r+L,p=a+k,y=n.slice(r,a),m=n.slice(a,p),c=n.slice(p);return{type:t,sealed:c,iv:m,senderPublicKey:y}}const o=r+k,s=n.slice(r,o),i=n.slice(o);return{type:t,sealed:i,iv:s}}function gn(e,n){const t=F(e);return ye({type:S(t.type),senderPublicKey:typeof t.senderPublicKey<\"u\"?l(t.senderPublicKey,u):void 0,receiverPublicKey:n?.receiverPublicKey})}function ye(e){const n=e?.type||K;if(n===b){if(typeof e?.senderPublicKey>\"u\")throw new Error(\"missing sender public key\");if(typeof e?.receiverPublicKey>\"u\")throw new Error(\"missing receiver public key\")}return{type:n,senderPublicKey:e?.senderPublicKey,receiverPublicKey:e?.receiverPublicKey}}function hn(e){return e.type===b&&typeof e.senderPublicKey==\"string\"&&typeof e.receiverPublicKey==\"string\"}var Nn=Object.defineProperty,Ee=Object.getOwnPropertySymbols,vn=Object.prototype.hasOwnProperty,bn=Object.prototype.propertyIsEnumerable,ge=(e,n,t)=>n in e?Nn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,he=(e,n)=>{for(var t in n||(n={}))vn.call(n,t)&&ge(e,t,n[t]);if(Ee)for(var t of Ee(n))bn.call(n,t)&&ge(e,t,n[t]);return e};const Ne=\"ReactNative\",O={reactNative:\"react-native\",node:\"node\",browser:\"browser\",unknown:\"unknown\"},C=\" \",On=\":\",ve=\"/\",x=2,Sn=1e3,be=\"js\";function H(){return typeof process<\"u\"&&typeof process.versions<\"u\"&&typeof process.versions.node<\"u\"}function Oe(){return!Ze()&&!!te()&&navigator.product===Ne}function Se(){return!H()&&!!te()}function q(){return Oe()?O.reactNative:H()?O.node:Se()?O.browser:O.unknown}function Ie(e,n){let t=P.parse(e);return t=he(he({},t),n),e=P.stringify(t),e}function In(){return Xe()||{name:\"\",description:\"\",url:\"\",icons:[\"\"]}}function Pn(e,n){var t;const r=q(),o={protocol:e,version:n,env:r};return r===\"browser\"&&(o.host=((t=re())==null?void 0:t.host)||\"unknown\"),o}function Pe(){const e=Je();if(e===null)return\"unknown\";const n=e.os?e.os.replace(\" \",\"\").toLowerCase():\"unknown\";return e.type===\"browser\"?[n,e.name,e.version].join(\"-\"):[n,e.version].join(\"-\")}function Te(){var e;const n=q();return n===O.browser?[n,((e=re())==null?void 0:e.host)||\"unknown\"].join(\":\"):n}function Re(e,n,t){const r=Pe(),o=Te();return[[e,n].join(\"-\"),[be,t].join(\"-\"),r,o].join(\"/\")}function Tn({protocol:e,version:n,relayUrl:t,sdkVersion:r,auth:o,projectId:s,useOnCloseEvent:i}){const a=t.split(\"?\"),p=Re(e,n,r),y={auth:o,ua:p,projectId:s,useOnCloseEvent:i||void 0},m=Ie(a[1]||\"\",y);return a[0]+\"?\"+m}function Rn(e){let n=(e.match(/^[^:]+(?=:\\/\\/)/gi)||[])[0];const t=typeof n<\"u\"?e.split(\"://\")[1]:e;return n=n===\"wss\"?\"https\":\"http\",[n,t].join(\"://\")}function Un(e,n,t){if(!e[n]||typeof e[n]!==t)throw new Error(`Missing or invalid \"${n}\" param`)}function Ue(e,n=x){return Ae(e.split(ve),n)}function An(e){return Ue(e).join(C)}function g(e,n){return e.filter(t=>n.includes(t)).length===e.length}function Ae(e,n=x){return e.slice(Math.max(e.length-n,0))}function _n(e){return Object.fromEntries(e.entries())}function Cn(e){return new Map(Object.entries(e))}function wn(e,n){const t={};return Object.keys(e).forEach(r=>{t[r]=n(e[r])}),t}const $n=e=>e;function _e(e){return e.trim().replace(/^\\w/,n=>n.toUpperCase())}function Dn(e){return e.split(C).map(n=>_e(n)).join(C)}function jn(e=ne,n){const t=D(e||ne);let r,o,s;return{resolve:i=>{s&&r&&(clearTimeout(s),r(i))},reject:i=>{s&&o&&(clearTimeout(s),o(i))},done:()=>new Promise((i,a)=>{s=setTimeout(()=>{a(new Error(n))},t),r=i,o=a})}}function Vn(e,n,t){return new Promise(async(r,o)=>{const s=setTimeout(()=>o(new Error(t)),n);try{const i=await e;r(i)}catch(i){o(i)}clearTimeout(s)})}function B(e,n){if(typeof n==\"string\"&&n.startsWith(`${e}:`))return n;if(e.toLowerCase()===\"topic\"){if(typeof n!=\"string\")throw new Error('Value must be \"string\" for expirer target type: topic');return`topic:${n}`}else if(e.toLowerCase()===\"id\"){if(typeof n!=\"number\")throw new Error('Value must be \"number\" for expirer target type: id');return`id:${n}`}throw new Error(`Unknown expirer target type: ${e}`)}function Mn(e){return B(\"topic\",e)}function Kn(e){return B(\"id\",e)}function kn(e){const[n,t]=e.split(\":\"),r={id:void 0,topic:void 0};if(n===\"topic\"&&typeof t==\"string\")r.topic=t;else if(n===\"id\"&&Number.isInteger(Number(t)))r.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);return r}function Ln(e,n){return Qe((n||Date.now())+D(e))}function Fn(e){return Date.now()>=D(e)}function xn(e,n){return`${e}${n?`:${n}`:\"\"}`}const Ce=\"irn\";function Hn(e){return e?.relay||{protocol:Ce}}function qn(e){const n=en[e];if(typeof n>\"u\")throw new Error(`Relay Protocol not supported: ${e}`);return n}var Bn=Object.defineProperty,we=Object.getOwnPropertySymbols,Gn=Object.prototype.hasOwnProperty,zn=Object.prototype.propertyIsEnumerable,$e=(e,n,t)=>n in e?Bn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Yn=(e,n)=>{for(var t in n||(n={}))Gn.call(n,t)&&$e(e,t,n[t]);if(we)for(var t of we(n))zn.call(n,t)&&$e(e,t,n[t]);return e};function De(e,n=\"-\"){const t={},r=\"relay\"+n;return Object.keys(e).forEach(o=>{if(o.startsWith(r)){const s=o.replace(r,\"\"),i=e[o];t[s]=i}}),t}function Wn(e){const n=e.indexOf(\":\"),t=e.indexOf(\"?\")!==-1?e.indexOf(\"?\"):void 0,r=e.substring(0,n),o=e.substring(n+1,t).split(\"@\"),s=typeof t<\"u\"?e.substring(t):\"\",i=P.parse(s);return{protocol:r,topic:o[0],version:parseInt(o[1],10),symKey:i.symKey,relay:De(i)}}function je(e,n=\"-\"){const t=\"relay\",r={};return Object.keys(e).forEach(o=>{const s=t+n+o;e[o]&&(r[s]=e[o])}),r}function Jn(e){return`${e.protocol}:${e.topic}@${e.version}?`+P.stringify(Yn({symKey:e.symKey},je(e.relay)))}function N(e){const n=[];return e.forEach(t=>{const[r,o]=t.split(\":\");n.push(`${r}:${o}`)}),n}function Ve(e){const n=[];return Object.values(e).forEach(t=>{n.push(...N(t.accounts))}),n}function Me(e,n){const t=[];return Object.values(e).forEach(r=>{N(r.accounts).includes(n)&&t.push(...r.methods)}),t}function Ke(e,n){const t=[];return Object.values(e).forEach(r=>{N(r.accounts).includes(n)&&t.push(...r.events)}),t}function Qn(e,n){const t=Be(e,n);if(t)throw new Error(t.message);const r={};for(const[o,s]of Object.entries(e))r[o]={methods:s.methods,events:s.events,chains:s.accounts.map(i=>`${i.split(\":\")[0]}:${i.split(\":\")[1]}`)};return r}const Zn={INVALID_METHOD:{message:\"Invalid method.\",code:1001},INVALID_EVENT:{message:\"Invalid event.\",code:1002},INVALID_UPDATE_REQUEST:{message:\"Invalid update request.\",code:1003},INVALID_EXTEND_REQUEST:{message:\"Invalid extend request.\",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:\"Invalid session settle request.\",code:1005},UNAUTHORIZED_METHOD:{message:\"Unauthorized method.\",code:3001},UNAUTHORIZED_EVENT:{message:\"Unauthorized event.\",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:\"Unauthorized update request.\",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:\"Unauthorized extend request.\",code:3004},USER_REJECTED:{message:\"User rejected.\",code:5e3},USER_REJECTED_CHAINS:{message:\"User rejected chains.\",code:5001},USER_REJECTED_METHODS:{message:\"User rejected methods.\",code:5002},USER_REJECTED_EVENTS:{message:\"User rejected events.\",code:5003},UNSUPPORTED_CHAINS:{message:\"Unsupported chains.\",code:5100},UNSUPPORTED_METHODS:{message:\"Unsupported methods.\",code:5101},UNSUPPORTED_EVENTS:{message:\"Unsupported events.\",code:5102},UNSUPPORTED_ACCOUNTS:{message:\"Unsupported accounts.\",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:\"Unsupported namespace key.\",code:5104},USER_DISCONNECTED:{message:\"User disconnected.\",code:6e3},SESSION_SETTLEMENT_FAILED:{message:\"Session settlement failed.\",code:7e3},WC_METHOD_UNSUPPORTED:{message:\"Unsupported wc_ method.\",code:10001}},Xn={NOT_INITIALIZED:{message:\"Not initialized.\",code:1},NO_MATCHING_KEY:{message:\"No matching key.\",code:2},RESTORE_WILL_OVERRIDE:{message:\"Restore will override.\",code:3},RESUBSCRIBED:{message:\"Resubscribed.\",code:4},MISSING_OR_INVALID:{message:\"Missing or invalid.\",code:5},EXPIRED:{message:\"Expired.\",code:6},UNKNOWN_TYPE:{message:\"Unknown type.\",code:7},MISMATCHED_TOPIC:{message:\"Mismatched topic.\",code:8},NON_CONFORMING_NAMESPACES:{message:\"Non conforming namespaces.\",code:9}};function E(e,n){const{message:t,code:r}=Xn[e];return{message:n?`${t} ${n}`:t,code:r}}function v(e,n){const{message:t,code:r}=Zn[e];return{message:n?`${t} ${n}`:t,code:r}}function I(e,n){return Array.isArray(e)?typeof n<\"u\"&&e.length?e.every(n):!0:!1}function G(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function h(e){return typeof e>\"u\"}function d(e,n){return n&&h(e)?!0:typeof e==\"string\"&&Boolean(e.trim().length)}function w(e,n){return n&&h(e)?!0:typeof e==\"number\"&&!isNaN(e)}function et(e,n){const{requiredNamespaces:t}=n,r=Object.keys(e.namespaces),o=Object.keys(t);let s=!0;return g(o,r)?(r.forEach(i=>{const{accounts:a,methods:p,events:y}=e.namespaces[i],m=N(a),c=t[i];(!g(R(i,c),m)||!g(c.methods,p)||!g(c.events,y))&&(s=!1)}),s):!1}function $(e){return d(e,!1)&&e.includes(\":\")?e.split(\":\").length===2:!1}function ke(e){if(d(e,!1)&&e.includes(\":\")){const n=e.split(\":\");if(n.length===3){const t=n[0]+\":\"+n[1];return!!n[2]&&$(t)}}return!1}function nt(e){if(d(e,!1))try{return typeof new URL(e)<\"u\"}catch{return!1}return!1}function tt(e){var n;return(n=e?.proposer)==null?void 0:n.publicKey}function rt(e){return e?.topic}function ot(e,n){let t=null;return d(e?.publicKey,!1)||(t=E(\"MISSING_OR_INVALID\",`${n} controller public key should be a string`)),t}function z(e){let n=!0;return I(e)?e.length&&(n=e.every(t=>d(t,!1))):n=!1,n}function Le(e,n,t){let r=null;return I(n)?n.forEach(o=>{r||(!$(o)||!o.includes(e))&&(r=v(\"UNSUPPORTED_CHAINS\",`${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`))}):r=v(\"UNSUPPORTED_CHAINS\",`${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`),r}function Fe(e,n){let t=null;return Object.entries(e).forEach(([r,o])=>{if(t)return;const s=Le(r,R(r,o),`${n} requiredNamespace`);s&&(t=s)}),t}function xe(e,n){let t=null;return I(e)?e.forEach(r=>{t||ke(r)||(t=v(\"UNSUPPORTED_ACCOUNTS\",`${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`))}):t=v(\"UNSUPPORTED_ACCOUNTS\",`${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`),t}function He(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=xe(r?.accounts,`${n} namespace`);o&&(t=o)}),t}function qe(e,n){let t=null;return z(e?.methods)?z(e?.events)||(t=v(\"UNSUPPORTED_EVENTS\",`${n}, events should be an array of strings or empty array for no events`)):t=v(\"UNSUPPORTED_METHODS\",`${n}, methods should be an array of strings or empty array for no methods`),t}function Y(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=qe(r,`${n}, namespace`);o&&(t=o)}),t}function st(e,n,t){let r=null;if(e&&G(e)){const o=Y(e,n);o&&(r=o);const s=Fe(e,n);s&&(r=s)}else r=E(\"MISSING_OR_INVALID\",`${n}, ${t} should be an object with data`);return r}function Be(e,n){let t=null;if(e&&G(e)){const r=Y(e,n);r&&(t=r);const o=He(e,n);o&&(t=o)}else t=E(\"MISSING_OR_INVALID\",`${n}, namespaces should be an object with data`);return t}function Ge(e){return d(e.protocol,!0)}function it(e,n){let t=!1;return n&&!e?t=!0:e&&I(e)&&e.length&&e.forEach(r=>{t=Ge(r)}),t}function ct(e){return typeof e==\"number\"}function at(e){return typeof e<\"u\"&&typeof e!==null}function ut(e){return!(!e||typeof e!=\"object\"||!e.code||!w(e.code,!1)||!e.message||!d(e.message,!1))}function dt(e){return!(h(e)||!d(e.method,!1))}function lt(e){return!(h(e)||h(e.result)&&h(e.error)||!w(e.id,!1)||!d(e.jsonrpc,!1))}function ft(e){return!(h(e)||!d(e.name,!1))}function pt(e,n){return!(!$(n)||!Ve(e).includes(n))}function mt(e,n,t){return d(t,!1)?Me(e,n).includes(t):!1}function yt(e,n,t){return d(t,!1)?Ke(e,n).includes(t):!1}function Et(e,n,t){let r=null;const o=gt(e),s=ht(n),i=Object.keys(o),a=Object.keys(s),p=ze(Object.keys(e)),y=ze(Object.keys(n)),m=p.filter(c=>!y.includes(c));return m.length&&(r=E(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${m.toString()}\n      Received: ${Object.keys(n).toString()}`)),g(i,a)||(r=E(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${a.toString()}`)),Object.keys(n).forEach(c=>{if(!c.includes(\":\")||r)return;const W=N(n[c].accounts);W.includes(c)||(r=E(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces accounts don't satisfy namespace accounts for ${c}\n        Required: ${c}\n        Approved: ${W.toString()}`))}),i.forEach(c=>{r||(g(o[c].methods,s[c].methods)?g(o[c].events,s[c].events)||(r=E(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces events don't satisfy namespace events for ${c}`)):r=E(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces methods don't satisfy namespace methods for ${c}`))}),r}function gt(e){const n={};return Object.keys(e).forEach(t=>{var r;t.includes(\":\")?n[t]=e[t]:(r=e[t].chains)==null||r.forEach(o=>{n[o]={methods:e[t].methods,events:e[t].events}})}),n}function ze(e){return[...new Set(e.map(n=>n.includes(\":\")?n.split(\":\")[0]:n))]}function ht(e){const n={};return Object.keys(e).forEach(t=>{if(t.includes(\":\"))n[t]=e[t];else{const r=N(e[t].accounts);r?.forEach(o=>{n[o]={accounts:e[t].accounts.filter(s=>s.includes(`${o}:`)),methods:e[t].methods,events:e[t].events}})}}),n}function Nt(e,n){return w(e,!1)&&e<=n.max&&e>=n.min}export{M as BASE10,u as BASE16,A as BASE64,On as COLON,x as DEFAULT_DEPTH,C as EMPTY_SPACE,O as ENV_MAP,Sn as ONE_THOUSAND,Ne as REACT_NATIVE_PRODUCT,Ce as RELAYER_DEFAULT_PROTOCOL,be as SDK_TYPE,ve as SLASH,K as TYPE_0,b as TYPE_1,_ as UTF8,Ie as appendToQueryString,Un as assertType,Ln as calcExpiry,Dn as capitalize,_e as capitalizeWord,jn as createDelayedPromise,Vn as createExpiringPromise,S as decodeTypeByte,En as decrypt,fn as deriveSymKey,F as deserialize,pe as encodeTypeByte,yn as encrypt,xn as engineEvent,$n as enumify,ie as formatAccountId,nn as formatAccountWithChain,se as formatChainId,B as formatExpirerTarget,Kn as formatIdTarget,an as formatMessage,An as formatMessageContext,je as formatRelayParams,Tn as formatRelayRpcUrl,Mn as formatTopicTarget,Re as formatUA,Jn as formatUri,dn as generateKeyPair,ln as generateRandomBytes32,N as getAccountsChains,rn as getAccountsFromNamespaces,ce as getAddressFromAccount,tn as getAddressesFromAccounts,In as getAppMetadata,ae as getChainFromAccount,ue as getChainsFromAccounts,R as getChainsFromNamespace,on as getChainsFromNamespaces,sn as getChainsFromRequiredNamespaces,le as getDidAddress,U as getDidAddressSegments,de as getDidChainId,q as getEnvironment,Rn as getHttpUrl,E as getInternalError,Te as getJavascriptID,Pe as getJavascriptOS,Ae as getLastItems,cn as getNamespacedDidChainId,Ve as getNamespacesChains,Ke as getNamespacesEventsForChainId,Me as getNamespacesMethodsForChainId,Pn as getRelayClientMetadata,qn as getRelayProtocolApi,Hn as getRelayProtocolName,Qn as getRequiredNamespacesFromNamespaces,v as getSdkError,V as getUniqueValues,g as hasOverlap,pn as hashKey,mn as hashMessage,Se as isBrowser,Et as isConformingNamespaces,Fn as isExpired,H as isNode,tt as isProposalStruct,Oe as isReactNative,et as isSessionCompatible,rt as isSessionStruct,hn as isTypeOneEnvelope,h as isUndefined,ke as isValidAccountId,xe as isValidAccounts,qe as isValidActions,I as isValidArray,$ as isValidChainId,Le as isValidChains,ot as isValidController,ut as isValidErrorReason,ft as isValidEvent,ct as isValidId,He as isValidNamespaceAccounts,Y as isValidNamespaceActions,Fe as isValidNamespaceChains,z as isValidNamespaceMethodsOrEvents,Be as isValidNamespaces,pt as isValidNamespacesChainId,yt as isValidNamespacesEvent,mt as isValidNamespacesRequest,w as isValidNumber,G as isValidObject,at as isValidParams,Ge as isValidRelay,it as isValidRelays,dt as isValidRequest,Nt as isValidRequestExpiry,st as isValidRequiredNamespaces,lt as isValidResponse,d as isValidString,nt as isValidUrl,wn as mapEntries,_n as mapToObj,Cn as objToMap,j as parseAccountId,oe as parseChainId,Ue as parseContextNames,kn as parseExpirerTarget,De as parseRelayParams,Wn as parseUri,me as serialize,gn as validateDecoding,ye as validateEncoding};\n//# sourceMappingURL=index.es.js.map\n"]},"metadata":{},"sourceType":"module"}