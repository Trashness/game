{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var newPageParams = oldPageParams;\n        var cancelled = false;\n        var addSignalProperty = function addSignalProperty(object) {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: function get() {\n              var _context$signal;\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', function () {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        };\n        var buildNewPages = function buildNewPages(pages, param, page, previous) {\n          newPageParams = previous ? [param].concat(_toConsumableArray(newPageParams)) : [].concat(_toConsumableArray(newPageParams), [param]);\n          return previous ? [page].concat(_toConsumableArray(pages)) : [].concat(_toConsumableArray(pages), [page]);\n        }; // Create function to fetch a page\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          var queryFnResult = queryFn(queryFnContext);\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            return buildNewPages(pages, param, page, previous);\n          });\n          return promise;\n        };\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          var manual = typeof pageParam !== 'undefined';\n          var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          var _manual = typeof pageParam !== 'undefined';\n          var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, _manual, _param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          var _manual2 = typeof context.options.getNextPageParam === 'undefined';\n          var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], _manual2, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n          var _loop = function _loop(i) {\n            promise = promise.then(function (pages) {\n              var shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n              if (shouldFetchNextPage) {\n                var _param2 = _manual2 ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, _manual2, _param2);\n              }\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          };\n          for (var i = 1; i < oldPages.length; i++) {\n            _loop(i);\n          }\n        }\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n  return;\n}\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"sources":["../../src/infiniteQueryBehavior.ts"],"names":["infiniteQueryBehavior","onFetch","context","fetchFn","refetchPage","fetchOptions","meta","fetchMore","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","newPageParams","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","options","Promise","reject","buildNewPages","param","page","previous","fetchPage","manual","length","resolve","queryFnContext","queryKey","queryFnResult","promise","then","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","i","shouldFetchNextPage","finalPromise","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"mappings":";AASO,SAASA,qBAAT,CAAA,EAIuD;EAC5D,OAAO;IACLC,OAAO,EAAGC,SAAAA,QAAAA,OAAD,EAAa;MACpBA,OAAO,CAACC,OAARD,GAAkB,YAAM;QAAA,IAAA,qBAAA,EAAA,sBAAA,EAAA,sBAAA,EAAA,sBAAA,EAAA,mBAAA,EAAA,oBAAA;QACtB,IAAME,WAA2D,GAC/DF,CAAAA,qBAAAA,GAAAA,OAAO,CAACG,YADuD,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,CAAA,sBAAA,GAC/DH,qBAAsBI,CAAAA,IADyC,KAC/DJ,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,sBAAAA,CAA4BE,WAD9B;QAEA,IAAMG,SAAS,GAAGL,CAAAA,sBAAAA,GAAAA,OAAO,CAACG,YAAX,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,CAAA,sBAAA,GAAGH,sBAAsBI,CAAAA,IAAzB,KAAGJ,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,sBAAAA,CAA4BK,SAA9C;QACA,IAAMC,SAAS,GAAGD,SAAH,IAAGA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,SAAS,CAAEC,SAA7B;QACA,IAAMC,kBAAkB,GAAG,CAAA,SAAS,IAAA,IAAT,GAAA,KAAA,CAAA,GAAA,SAAS,CAAEC,SAAX,MAAyB,SAApD;QACA,IAAMC,sBAAsB,GAAG,CAAA,SAAS,IAAA,IAAT,GAAA,KAAA,CAAA,GAAA,SAAS,CAAED,SAAX,MAAyB,UAAxD;QACA,IAAME,QAAQ,GAAG,CAAA,CAAA,mBAAA,GAAA,OAAO,CAACC,KAAR,CAAcC,IAAd,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,mBAAA,CAAoBC,KAApB,KAA6B,EAA9C;QACA,IAAMC,aAAa,GAAG,CAAA,CAAA,oBAAA,GAAA,OAAO,CAACH,KAAR,CAAcC,IAAd,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,oBAAA,CAAoBG,UAApB,KAAkC,EAAxD;QACA,IAAIC,aAAa,GAAGF,aAApB;QACA,IAAIG,SAAS,GAAG,KAAhB;QAEA,IAAMC,iBAAiB,GAAIC,SAArBD,iBAAiB,CAAIC,MAAD,EAAqB;UAC7CC,MAAM,CAACC,cAAPD,CAAsBD,MAAtBC,EAA8B,QAA9BA,EAAwC;YACtCE,UAAU,EAAE,IAD0B;YAEtCC,GAAG,EAAE,SAAA,IAAA,EAAM;cAAA,IAAA,eAAA;cACT,IAAA,CAAA,eAAA,GAAIvB,OAAO,CAACwB,MAAZ,KAAIxB,IAAAA,IAAAA,eAAAA,CAAgByB,OAApB,EAA6B;gBAC3BR,SAAS,GAAG,IAAZA;cACD,CAFD,MAEO;gBAAA,IAAA,gBAAA;gBACL,CAAA,gBAAA,GAAA,OAAO,CAACO,MAAR,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,gBAAA,CAAgBE,gBAAhB,CAAiC,OAAjC,EAA0C,YAAM;kBAC9CT,SAAS,GAAG,IAAZA;iBADF,CAAA;cAGD;cACD,OAAOjB,OAAO,CAACwB,MAAf;YACD;WAXHJ,CAAAA;QAaD,CAdD,CAZsB,CAAA;;QA6BtB,IAAMO,OAAO,GACX3B,OAAO,CAAC4B,OAAR5B,CAAgB2B,OAAhB3B,IAA4B;UAAA,OAAM6B,OAAO,CAACC,MAARD,CAAe,iBAAfA,CAAlC7B;QAAAA,CADF;QAGA,IAAM+B,aAAa,GAAG,SAAhBA,aAAa,CACjBlB,KADoB,EAEpBmB,KAFoB,EAGpBC,IAHoB,EAIpBC,QAJoB,EAKjB;UACHlB,aAAa,GAAGkB,QAAQ,IACnBF,KAAD,EAAA,MAAA,CAAA,kBAAA,CAAWhB,aADS,QAAA,MAAA,CAAA,kBAAA,CAEhBA,aAAJ,IAAmBgB,KAAnB,EAFJhB;UAGA,OAAOkB,QAAQ,IAAID,IAAD,EAAA,MAAA,CAAA,kBAAA,CAAUpB,KAAb,QAAA,MAAA,CAAA,kBAAA,CAA0BA,KAAJ,IAAWoB,IAAX,EAArC;QACD,CAVD,CAhCsB,CAAA;;QA6CtB,IAAME,SAAS,GAAG,SAAZA,SAAS,CACbtB,KADgB,EAEhBuB,MAFgB,EAGhBJ,KAHgB,EAIhBE,QAJgB,EAKO;UACvB,IAAIjB,SAAJ,EAAe;YACb,OAAOY,OAAO,CAACC,MAARD,CAAe,WAAfA,CAAP;UACD;UAED,IAAI,OAAOG,KAAP,KAAiB,WAAjB,IAAgC,CAACI,MAAjC,IAA2CvB,KAAK,CAACwB,MAArD,EAA6D;YAC3D,OAAOR,OAAO,CAACS,OAART,CAAgBhB,KAAhBgB,CAAP;UACD;UAED,IAAMU,cAAoC,GAAG;YAC3CC,QAAQ,EAAExC,OAAO,CAACwC,QADyB;YAE3ClC,SAAS,EAAE0B,KAFgC;YAG3C5B,IAAI,EAAEJ,OAAO,CAAC4B,OAAR5B,CAAgBI;WAHxB;UAMAc,iBAAiB,CAACqB,cAAD,CAAjBrB;UAEA,IAAMuB,aAAa,GAAGd,OAAO,CAACY,cAAD,CAA7B;UAEA,IAAMG,OAAO,GAAGb,OAAO,CAACS,OAART,CAAgBY,aAAhBZ,CAA+Bc,CAAAA,IAA/Bd,CAAqCI,UAAAA,IAAD;YAAA,OAClDF,aAAa,CAAClB,KAAD,EAAQmB,KAAR,EAAeC,IAAf,EAAqBC,QAArB,CADCL;UAAAA,EAAhB;UAIA,OAAOa,OAAP;SA5BF;QA+BA,IAAIA,OAAJ,CA5EsB,CAAA;;QA+EtB,IAAI,CAAChC,QAAQ,CAAC2B,MAAd,EAAsB;UACpBK,OAAO,GAAGP,SAAS,CAAC,EAAD,CAAnBO;QACD,CAFD,CAAA;QAAA,KAKK,IAAInC,kBAAJ,EAAwB;UAC3B,IAAM6B,MAAM,GAAG,OAAO9B,SAAP,KAAqB,WAApC;UACA,IAAM0B,KAAK,GAAGI,MAAM,GAChB9B,SADgB,GAEhBsC,gBAAgB,CAAC5C,OAAO,CAAC4B,OAAT,EAAkBlB,QAAlB,CAFpB;UAGAgC,OAAO,GAAGP,SAAS,CAACzB,QAAD,EAAW0B,MAAX,EAAmBJ,KAAnB,CAAnBU;QACD,CANI,CAAA;QAAA,KASA,IAAIjC,sBAAJ,EAA4B;UAC/B,IAAM2B,OAAM,GAAG,OAAO9B,SAAP,KAAqB,WAApC;UACA,IAAM0B,MAAK,GAAGI,OAAM,GAChB9B,SADgB,GAEhBuC,oBAAoB,CAAC7C,OAAO,CAAC4B,OAAT,EAAkBlB,QAAlB,CAFxB;UAGAgC,OAAO,GAAGP,SAAS,CAACzB,QAAD,EAAW0B,OAAX,EAAmBJ,MAAnB,EAA0B,IAA1B,CAAnBU;QACD,CANI,CAAA;QAAA,KASA;UACH1B,aAAa,GAAG,EAAhBA;UAEA,IAAMoB,QAAM,GAAG,OAAOpC,OAAO,CAAC4B,OAAR5B,CAAgB4C,gBAAvB,KAA4C,WAA3D;UAEA,IAAME,oBAAoB,GACxB5C,WAAW,IAAIQ,QAAQ,CAAC,CAAD,CAAvBR,GACIA,WAAW,CAACQ,QAAQ,CAAC,CAAD,CAAT,EAAc,CAAd,EAAiBA,QAAjB,CADfR,GAEI,IAHN,CALG,CAAA;;UAWHwC,OAAO,GAAGI,oBAAoB,GAC1BX,SAAS,CAAC,EAAD,EAAKC,QAAL,EAAatB,aAAa,CAAC,CAAD,CAA1B,CADiB,GAE1Be,OAAO,CAACS,OAART,CAAgBE,aAAa,CAAC,EAAD,EAAKjB,aAAa,CAAC,CAAD,CAAlB,EAAuBJ,QAAQ,CAAC,CAAD,CAA/B,CAA7BmB,CAFJa,CAXG,CAAA;UAAA,IAAA,KAAA,YAAA,MAAA,CAAA,EAgBuC;YACxCA,OAAO,GAAG,OAAO,CAACC,IAAR,CAAc9B,UAAAA,KAAD,EAAW;cAChC,IAAMmC,mBAAmB,GACvB9C,WAAW,IAAIQ,QAAQ,CAACqC,CAAD,CAAvB7C,GACIA,WAAW,CAACQ,QAAQ,CAACqC,CAAD,CAAT,EAAcA,CAAd,EAAiBrC,QAAjB,CADfR,GAEI,IAHN;cAKA,IAAI8C,mBAAJ,EAAyB;gBACvB,IAAMhB,OAAK,GAAGI,QAAM,GAChBtB,aAAa,CAACiC,CAAD,CADG,GAEhBH,gBAAgB,CAAC5C,OAAO,CAAC4B,OAAT,EAAkBf,KAAlB,CAFpB;gBAGA,OAAOsB,SAAS,CAACtB,KAAD,EAAQuB,QAAR,EAAgBJ,OAAhB,CAAhB;cACD;cACD,OAAOH,OAAO,CAACS,OAART,CACLE,aAAa,CAAClB,KAAD,EAAQC,aAAa,CAACiC,CAAD,CAArB,EAA0BrC,QAAQ,CAACqC,CAAD,CAAlC,CADRlB,CAAP;YAGD,CAfS,CAAVa;UAgBD,CAAA;UAjBD,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrC,QAAQ,CAAC2B,MAA7B,EAAqCU,CAAC,EAAtC;YAAA,KAAA,CAAA,CAAA;UAAA;QAkBD;QAED,IAAME,YAAY,GAAG,OAAO,CAACN,IAAR,CAAc9B,UAAAA,KAAD;UAAA,OAAY;YAC5CA,KAD4C,EAC5CA,KAD4C;YAE5CE,UAAU,EAAEC;UAFgC,CAAZ;QAAA,CAAb,CAArB;QAKA,OAAOiC,YAAP;OA/IFjD;IAiJD;GAnJH;AAqJD;AAEM,SAAS4C,gBAAT,CACLhB,OADK,EAELf,KAFK,EAGgB;EACrB,OAAOe,OAAO,CAACgB,gBAAf,IAAA,IAAA,GAAA,KAAA,CAAA,GAAOhB,OAAO,CAACgB,gBAARhB,CAA2Bf,KAAK,CAACA,KAAK,CAACwB,MAANxB,GAAe,CAAhB,CAAhCe,EAAoDf,KAApDe,CAAP;AACD;AAEM,SAASiB,oBAAT,CACLjB,OADK,EAELf,KAFK,EAGgB;EACrB,OAAOe,OAAO,CAACiB,oBAAf,IAAA,IAAA,GAAA,KAAA,CAAA,GAAOjB,OAAO,CAACiB,oBAARjB,CAA+Bf,KAAK,CAAC,CAAD,CAApCe,EAAyCf,KAAzCe,CAAP;AACD;AAED;AACA;AACA;AACA;;AACO,SAASsB,WAAT,CACLtB,OADK,EAELf,KAFK,EAGgB;EACrB,IAAIe,OAAO,CAACgB,gBAARhB,IAA4BuB,KAAK,CAACC,OAAND,CAActC,KAAdsC,CAAhC,EAAsD;IACpD,IAAME,aAAa,GAAGT,gBAAgB,CAAChB,OAAD,EAAUf,KAAV,CAAtC;IACA,OACE,OAAOwC,aAAP,KAAyB,WAAzB,IACAA,aAAa,KAAK,IADlB,IAEAA,aAAa,KAAK,KAHpB;EAKD;EACD;AACD;AAED;AACA;AACA;AACA;;AACO,SAASC,eAAT,CACL1B,OADK,EAELf,KAFK,EAGgB;EACrB,IAAIe,OAAO,CAACiB,oBAARjB,IAAgCuB,KAAK,CAACC,OAAND,CAActC,KAAdsC,CAApC,EAA0D;IACxD,IAAMI,iBAAiB,GAAGV,oBAAoB,CAACjB,OAAD,EAAUf,KAAV,CAA9C;IACA,OACE,OAAO0C,iBAAP,KAA6B,WAA7B,IACAA,iBAAiB,KAAK,IADtB,IAEAA,iBAAiB,KAAK,KAHxB;EAKD;EACD;AACD","sourcesContent":["import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n"]},"metadata":{},"sourceType":"module"}