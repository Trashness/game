{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n  var _useEthers = useEthers(),\n    library = _useEthers.library,\n    chainId = _useEthers.chainId;\n  var transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n  var _usePromiseTransactio = usePromiseTransaction(transactionChainId, options),\n    promiseTransaction = _usePromiseTransactio.promiseTransaction,\n    state = _usePromiseTransactio.state,\n    resetState = _usePromiseTransactio.resetState;\n  var _useState = useState(undefined),\n    _useState2 = _slicedToArray(_useState, 2),\n    events = _useState2[0],\n    setEvents = _useState2[1];\n  var config = useConfig();\n  var gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  var providers = useReadonlyNetworks();\n  var provider = transactionChainId && providers[transactionChainId];\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _a,\n      numberOfArgs,\n      _len,\n      args,\n      _key,\n      hasOpts,\n      signer,\n      contractWithSigner,\n      opts,\n      gasLimit,\n      modifiedOpts,\n      modifiedArgs,\n      receipt,\n      _events,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!contract) {\n            _context.next = 33;\n            break;\n          }\n          numberOfArgs = contract.interface.getFunction(functionName).inputs.length;\n          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = _args[_key];\n          }\n          hasOpts = args.length > numberOfArgs;\n          if (!(args.length !== numberOfArgs && args.length !== numberOfArgs + 1)) {\n            _context.next = 6;\n            break;\n          }\n          throw new Error(\"Invalid number of arguments for function \\\"\".concat(functionName, \"\\\".\"));\n        case 6:\n          signer = getSignerFromOptions(provider, options, library);\n          contractWithSigner = connectContractToSigner(contract, options, signer);\n          opts = hasOpts ? args[args.length - 1] : undefined;\n          if (!(typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit'))) {\n            _context.next = 13;\n            break;\n          }\n          _context.t0 = opts.gasLimit;\n          _context.next = 25;\n          break;\n        case 13:\n          _context.next = 15;\n          return estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n        case 15:\n          _context.t2 = _a = _context.sent;\n          _context.t1 = _context.t2 !== null;\n          if (!_context.t1) {\n            _context.next = 19;\n            break;\n          }\n          _context.t1 = _a !== void 0;\n        case 19:\n          if (!_context.t1) {\n            _context.next = 23;\n            break;\n          }\n          _context.t3 = _a;\n          _context.next = 24;\n          break;\n        case 23:\n          _context.t3 = null;\n        case 24:\n          _context.t0 = _context.t3;\n        case 25:\n          gasLimit = _context.t0;\n          modifiedOpts = Object.assign({\n            gasLimit: gasLimit\n          }, opts);\n          modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n          _context.next = 30;\n          return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _toConsumableArray(modifiedArgs).concat([modifiedOpts])), {\n            safeTransaction: {\n              to: contract.address,\n              value: opts === null || opts === void 0 ? void 0 : opts.value,\n              data: contract.interface.encodeFunctionData(functionName, modifiedArgs),\n              safeTxGas: gasLimit !== null && gasLimit !== void 0 ? gasLimit : undefined\n            }\n          });\n        case 30:\n          receipt = _context.sent;\n          if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n            _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n              try {\n                return log.address.toLowerCase() === contract.address.toLowerCase() ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n              } catch (_err) {\n                return accumulatedLogs;\n              }\n            }, []);\n            setEvents(_events);\n          }\n          return _context.abrupt(\"return\", receipt);\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  })), [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send: send,\n    state: state,\n    events: events,\n    resetState: resetState\n  };\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractFunction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n    if (contract.signer) {\n        return contract;\n    }\n    if (options && 'signer' in options) {\n        return contract.connect(options.signer);\n    }\n    if (librarySigner) {\n        return contract.connect(librarySigner);\n    }\n    throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n    var _a, _b, _c;\n    const { library, chainId } = useEthers();\n    const transactionChainId = (options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId)) || chainId;\n    const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options);\n    const [events, setEvents] = useState(undefined);\n    const config = useConfig();\n    const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n    const providers = useReadonlyNetworks();\n    const provider = (transactionChainId && providers[transactionChainId]);\n    const send = useCallback(async (...args) => {\n        var _a;\n        if (contract) {\n            const numberOfArgs = contract.interface.getFunction(functionName).inputs.length;\n            const hasOpts = args.length > numberOfArgs;\n            if (args.length !== numberOfArgs && args.length !== numberOfArgs + 1) {\n                throw new Error(`Invalid number of arguments for function \"${functionName}\".`);\n            }\n            const signer = getSignerFromOptions(provider, options, library);\n            const contractWithSigner = connectContractToSigner(contract, options, signer);\n            const opts = hasOpts ? args[args.length - 1] : undefined;\n            const gasLimit = typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit')\n                ? opts.gasLimit\n                : (_a = (await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage))) !== null && _a !== void 0 ? _a : null;\n            const modifiedOpts = Object.assign({ gasLimit }, opts);\n            const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n            const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs, modifiedOpts), {\n                safeTransaction: {\n                    to: contract.address,\n                    value: opts === null || opts === void 0 ? void 0 : opts.value,\n                    data: contract.interface.encodeFunctionData(functionName, modifiedArgs),\n                    safeTxGas: gasLimit !== null && gasLimit !== void 0 ? gasLimit : undefined,\n                },\n            });\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n                const events = receipt.logs.reduce((accumulatedLogs, log) => {\n                    try {\n                        return log.address.toLowerCase() === contract.address.toLowerCase()\n                            ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                            : accumulatedLogs;\n                    }\n                    catch (_err) {\n                        return accumulatedLogs;\n                    }\n                }, []);\n                setEvents(events);\n            }\n            return receipt;\n        }\n    }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n    return { send, state, events, resetState };\n}\n//# sourceMappingURL=useContractFunction.js.map"]},"metadata":{},"sourceType":"module"}