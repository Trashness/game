{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useEffect, useMemo, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { useReadonlyNetworks } from '../providers/network/readonlyNetworks';\nimport { useBlockNumbers, useBlockNumber } from '../hooks';\n/**\n * Returns all blockchain logs given a block filter.\n * The hook will cause the component to refresh when a new block is mined and the returned logs change.\n * @see {@link useLogs} for a more easy-to-use version of the query.\n * @param filter an event filter, which blocks to query\n * @param queryParams allows for additional configuration of the query (see {@link QueryParams})\n * @returns an array of [logs](https://docs.ethers.io/v5/api/providers/types/#providers-Log)\n * @public\n */\nexport function useRawLogs(filter) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _useEthers = useEthers(),\n    library = _useEthers.library;\n  var providers = useReadonlyNetworks();\n  var _blockNumber = useBlockNumber();\n  var blockNumbers = useBlockNumbers();\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    logs = _useState2[0],\n    setLogs = _useState2[1];\n  var chainId = queryParams.chainId;\n  var _useMemo = useMemo(function () {\n      return chainId ? [providers[chainId], blockNumbers[chainId]] : [library, _blockNumber];\n    }, [providers, library, blockNumbers, _blockNumber, chainId]),\n    _useMemo2 = _slicedToArray(_useMemo, 2),\n    provider = _useMemo2[0],\n    blockNumber = _useMemo2[1];\n  function updateLogs() {\n    return _updateLogs.apply(this, arguments);\n  }\n  function _updateLogs() {\n    _updateLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = setLogs;\n            if (filter) {\n              _context.next = 5;\n              break;\n            }\n            _context.t1 = undefined;\n            _context.next = 8;\n            break;\n          case 5:\n            _context.next = 7;\n            return provider === null || provider === void 0 ? void 0 : provider.getLogs(filter);\n          case 7:\n            _context.t1 = _context.sent;\n          case 8:\n            _context.t2 = _context.t1;\n            (0, _context.t0)(_context.t2);\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _updateLogs.apply(this, arguments);\n  }\n  useEffect(function () {\n    void updateLogs();\n  }, [provider, blockNumber]);\n  return logs;\n}","map":{"version":3,"sources":["../../../../src/hooks/useRawLogs.ts"],"names":[],"mappings":";;;AAAA,SAAS,SAAS,EAAE,OAAO,EAAE,QAAQ,QAAQ,OAAO;AACpD,SAAS,SAAS,QAAQ,aAAa;AACvC,SAAS,mBAAmB,QAAQ,uCAAuC;AAC3E,SAAS,eAAe,EAAE,cAAc,QAAQ,UAAU;AAK1D;;;;;;;;AAQG;AACH,OAAM,SAAU,UAAU,CACxB,MAAgF,EACnD;EAAA,IAA7B,WAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAA2B,CAAA,CAAE;EAE7B,IAAA,UAAA,GAAoB,SAAS,EAAE;IAAvB,OAAO,GAAA,UAAA,CAAP,OAAO;EACf,IAAM,SAAS,GAAG,mBAAmB,EAAE;EACvC,IAAM,YAAY,GAAG,cAAc,EAAE;EACrC,IAAM,YAAY,GAAG,eAAe,EAAE;EAEtC,IAAA,SAAA,GAAwB,QAAQ,EAAqB;IAAA,UAAA,GAAA,cAAA,CAAA,SAAA;IAA9C,IAAI,GAAA,UAAA;IAAE,OAAO,GAAA,UAAA;EAEpB,IAAQ,OAAO,GAAK,WAAW,CAAvB,OAAO;EAEf,IAAA,QAAA,GAAgC,OAAO,CACrC;MAAA,OAAO,OAAO,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,YAAY,CAAC;IAAA,CAAC,EACvF,CAAC,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,OAAO,CAAC,CAC1D;IAAA,SAAA,GAAA,cAAA,CAAA,QAAA;IAHM,QAAQ,GAAA,SAAA;IAAE,WAAW,GAAA,SAAA;EAG3B,SAEc,UAAU,CAAA;IAAA,OAAA,WAAA,CAAA,KAAA,OAAA,SAAA;EAAA;EAAA,SAAA,YAAA;IAAA,WAAA,GAAA,iBAAA,eAAA,mBAAA,GAAA,IAAA,CAAzB,SAAA,QAAA;MAAA,OAAA,mBAAA,GAAA,IAAA,UAAA,SAAA,QAAA;QAAA,kBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;UAAA;YAAA,QAAA,CAAA,EAAA,GACE,OAAO;YAAA,IAAE,MAAM;cAAA,QAAA,CAAA,IAAA;cAAA;YAAA;YAAA,QAAA,CAAA,EAAA,GAAG,SAAS;YAAA,QAAA,CAAA,IAAA;YAAA;UAAA;YAAA,QAAA,CAAA,IAAA;YAAA,OAAS,QAAQ,KAAA,IAAA,IAAR,QAAQ,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAR,QAAQ,CAAE,OAAO,CAAC,MAAM,CAAC;UAAA;YAAA,QAAA,CAAA,EAAA,GAAA,QAAA,CAAA,IAAA;UAAA;YAAA,QAAA,CAAA,EAAA,GAAA,QAAA,CAAA,EAAA;YAAA,IAAA,QAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA;UAAA;UAAA;YAAA,OAAA,QAAA,CAAA,IAAA;QAAA;MAAA,GAAA,OAAA;IAAA,CAC9D;IAAA,OAAA,WAAA,CAAA,KAAA,OAAA,SAAA;EAAA;EAED,SAAS,CAAC,YAAK;IACb,KAAK,UAAU,EAAE;EACnB,CAAC,EAAE,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;EAE3B,OAAO,IAAI;AACb","sourceRoot":"","sourcesContent":["import { useEffect, useMemo, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { useReadonlyNetworks } from '../providers/network/readonlyNetworks';\nimport { useBlockNumbers, useBlockNumber } from '../hooks';\n/**\n * Returns all blockchain logs given a block filter.\n * The hook will cause the component to refresh when a new block is mined and the returned logs change.\n * @see {@link useLogs} for a more easy-to-use version of the query.\n * @param filter an event filter, which blocks to query\n * @param queryParams allows for additional configuration of the query (see {@link QueryParams})\n * @returns an array of [logs](https://docs.ethers.io/v5/api/providers/types/#providers-Log)\n * @public\n */\nexport function useRawLogs(filter, queryParams = {}) {\n    const { library } = useEthers();\n    const providers = useReadonlyNetworks();\n    const _blockNumber = useBlockNumber();\n    const blockNumbers = useBlockNumbers();\n    const [logs, setLogs] = useState();\n    const { chainId } = queryParams;\n    const [provider, blockNumber] = useMemo(() => (chainId ? [providers[chainId], blockNumbers[chainId]] : [library, _blockNumber]), [providers, library, blockNumbers, _blockNumber, chainId]);\n    async function updateLogs() {\n        setLogs(!filter ? undefined : await (provider === null || provider === void 0 ? void 0 : provider.getLogs(filter)));\n    }\n    useEffect(() => {\n        void updateLogs();\n    }, [provider, blockNumber]);\n    return logs;\n}\n//# sourceMappingURL=useRawLogs.js.map"]},"metadata":{},"sourceType":"module"}