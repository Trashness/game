{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n  console.warn(\"Invalid contract call: address=\".concat(call && call.address, \" method=\").concat(call && call.method, \" args=\").concat(call && call.args));\n}\nfunction encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args),\n      chainId: chainId\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var rawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      return chainId !== undefined ? encodeCallData(call, chainId) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    var _a;\n    return call && {\n      address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var results = useChainCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      var call = calls[idx];\n      if (result === '0x') {\n        warnOnInvalidContractCall(call);\n        return undefined;\n      }\n      return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n    });\n  }, [JSON.stringify(results)]);\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractCall.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n    console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\nfunction encodeCallData(call, chainId) {\n    if (!call) {\n        return undefined;\n    }\n    if (!call.address || !call.method) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n    try {\n        return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId };\n    }\n    catch (_a) {\n        warnOnInvalidContractCall(call);\n        return undefined;\n    }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call, queryParams = {}) {\n    return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls, queryParams = {}) {\n    const chainId = useChainId({ queryParams });\n    const rawCalls = useMemo(() => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)), [\n        JSON.stringify(calls.map((call) => { var _a; return call && { address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(), method: call.method, args: call.args }; })),\n        chainId,\n    ]);\n    const results = useChainCalls(rawCalls);\n    return useMemo(() => results.map((result, idx) => {\n        const call = calls[idx];\n        if (result === '0x') {\n            warnOnInvalidContractCall(call);\n            return undefined;\n        }\n        return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n    }), [JSON.stringify(results)]);\n}\n//# sourceMappingURL=useContractCall.js.map"]},"metadata":{},"sourceType":"module"}