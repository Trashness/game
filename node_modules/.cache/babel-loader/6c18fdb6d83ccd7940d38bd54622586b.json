{"ast":null,"code":"import _slicedToArray from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _inherits from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Kompa/Desktop/games/my-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { noChange as t } from \"../lit-html.js\";\nimport { directive as i, Directive as s, PartType as r } from \"../directive.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar o = i( /*#__PURE__*/function (_s) {\n  _inherits(_class, _s);\n  var _super = _createSuper(_class);\n  function _class(t) {\n    var _this;\n    _classCallCheck(this, _class);\n    var i;\n    if (_this = _super.call(this, t), t.type !== r.ATTRIBUTE || \"class\" !== t.name || (null === (i = t.strings) || void 0 === i ? void 0 : i.length) > 2) throw Error(\"`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.\");\n    return _possibleConstructorReturn(_this);\n  }\n  _createClass(_class, [{\n    key: \"render\",\n    value: function render(t) {\n      return \" \" + Object.keys(t).filter(function (i) {\n        return t[i];\n      }).join(\" \") + \" \";\n    }\n  }, {\n    key: \"update\",\n    value: function update(i, _ref) {\n      var _this2 = this;\n      var _ref2 = _slicedToArray(_ref, 1),\n        s = _ref2[0];\n      var r, o;\n      if (void 0 === this.nt) {\n        this.nt = new Set(), void 0 !== i.strings && (this.st = new Set(i.strings.join(\" \").split(/\\s/).filter(function (t) {\n          return \"\" !== t;\n        })));\n        for (var _t in s) s[_t] && !(null === (r = this.st) || void 0 === r ? void 0 : r.has(_t)) && this.nt.add(_t);\n        return this.render(s);\n      }\n      var e = i.element.classList;\n      this.nt.forEach(function (t) {\n        t in s || (e.remove(t), _this2.nt.delete(t));\n      });\n      for (var _t2 in s) {\n        var _i = !!s[_t2];\n        _i === this.nt.has(_t2) || (null === (o = this.st) || void 0 === o ? void 0 : o.has(_t2)) || (_i ? (e.add(_t2), this.nt.add(_t2)) : (e.remove(_t2), this.nt.delete(_t2)));\n      }\n      return t;\n    }\n  }]);\n  return _class;\n}(s));\nexport { o as classMap };","map":{"version":3,"sources":["../src/directives/class-map.ts"],"names":["Directive","constructor","partInfo","super","type","PartType","ATTRIBUTE","name","_a","strings","length","Error","render","classInfo","Object","keys","filter","key","join","update","part","this","_previousClasses","undefined","Set","_staticClasses","split","s","add","classList","element","forEach","remove","delete","value","has","_b","noChange","classMap","directive"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== '')\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach((name) => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    });\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"]},"metadata":{},"sourceType":"module"}